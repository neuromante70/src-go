{
    "sourceFile": "json2/main.go",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 92,
            "patches": [
                {
                    "date": 1689924302833,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1689924317848,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -25,16 +25,167 @@\n */\n \n package main\n \n-\n-\n import (\n \tc \"exercises/json/calculator\"\n \t\"fmt\"\n )\n+import (\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"os\"\n+)\n \n var prt = fmt.Println\n+\n+/*\n+1. Create a MathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the calculator.\n+So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n+*/\n+\n+type MathRequest struct {\n+\tNum1     int    `json:\"Num1\"`\n+\tOperator string `json:\"Operator\"`\n+\tNum2     int    `json:\"Num2\"`\n+}\n+\n+/*\n+2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n+*/\n+\n+type Calculator struct {\n+\tHistory []MathRequest\n+}\n+\n+func (c Calculator) Add(num1 int, num2 int) int {\n+\top := MathRequest{num1, \"Add\", num2}\n+\tc.History = append(c.History, op)\n+\treturn num1 + num2\n+}\n+\n+func (c Calculator) Sub(num1 int, num2 int) int {\n+\top := MathRequest{num1, \"Sub\", num2}\n+\tc.History = append(c.History, op)\n+\treturn num1 - num2\n+}\n+\n+func (c Calculator) Mult(num1 int, num2 int) int {\n+\top := MathRequest{num1, \"Mult\", num2}\n+\tc.History = append(c.History, op)\n+\treturn num1 * num2\n+}\n+\n+func (c Calculator) Divide(num1 int, num2 int) int {\n+\tif num2 == 0 {\n+\t\tprt(\"impossible to divide by zero\")\n+\t\treturn 0\n+\t}\n+\top := MathRequest{num1, \"Div\", num2}\n+\tc.History = append(c.History, op)\n+\treturn num1 / num2\n+}\n+\n+/*\n+3. create an encodeHistory function this will loop over all the mathRequests in the history slice inside the calculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax. So something like this:\n+func (c calculator) encodeHistory() []string {\n+    for _, mr := range c.history {\n+    }\n+}\n+*/\n+\n+func check(e error) (ok bool) {\n+\tif e != nil {\n+\t\tfmt.Printf(\"Error: %s\", e.Error())\n+\t\treturn false\n+\t}\n+\treturn true\n+}\n+\n+func (c Calculator) EncodeHistory() (eh []byte) {\n+\teh, err := json.Marshal(c.History)\n+\tif !check(err) {\n+\t\treturn nil\n+\t}\n+\t// prt(\"this is returned from json converter:\", string(j))\n+\treturn eh\n+}\n+\n+func (c Calculator) SaveToFile(eh []byte, fn string) {\n+\tf, err := os.Create(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\tn2, err := f.Write(eh) // I should check if the file already exists but...\n+\tif !check(err) {\n+\t\tf.Close()\n+\t}\n+\tprt(n2, \"bytes written successfully\")\n+\terr = f.Close()\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\tf2, err := os.ReadFile(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\tprt(\"this is \", fn, \" file: \", string(f2))\n+}\n+\n+/*\n+4. create a decodeHistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the calculator slice . At the start of this function clear out whatever was in the slice previously\n+json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n+*/\n+\n+func (c Calculator) DecodeHistory(fn string) (f []byte) {\n+\tf, err := os.ReadFile(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\t// var data []interface{}\n+\t// err = json.Unmarshal(f, &data)\n+\tmr := make([]MathRequest, 10)\n+\terr = json.Unmarshal(f, &mr)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\treturn f\n+}\n+\n+func (c Calculator) AddToHistory(fn string) {\n+\tmr := make([]MathRequest, 10)\n+\tf, err := os.ReadFile(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\terr = json.Unmarshal(f, &mr)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\t// for i := 0; i < len(mr)-1; i++ {\n+\t// \tMyCalc.History[i].num1 = mr[i].num1\n+\t// \tMyCalc.History[i].Operator = mr[i].Operator\n+\t// \tMyCalc.History[i].Num2 = mr[i].Num2\n+\t// }\n+\tc.History = nil\n+\tfor _, mRequest := range mr {\n+\t\tc.History = append(c.History, MathRequest(mRequest))\n+\t}\n+\t// for i := 0; i < len(mr); i++ {\n+\t// \top := MathRequest{mr[i].Num1, mr[i].Operator, mr[i].Num2}\n+\t// \tMyCalc.History = append(MyCalc.History, op)\n+\t// }\n+\tprt(\"this is the last history:\", c.PrintHistory())\n+}\n+\n+// ancillary function\n+func (c Calculator) PrintHistory() (history []string) {\n+\tfor _, v := range c.History {\n+\t\thistory = append(history, fmt.Sprintf(\"%+v\", v))\n+\t}\n+\treturn history\n+}\n+var prt = fmt.Println\n var calc c.Calculator\n \n func main() {\n \tprt(\"calculation with Calculator:\")\n"
                },
                {
                    "date": 1689924325682,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -28,12 +28,9 @@\n \n import (\n \tc \"exercises/json/calculator\"\n \t\"fmt\"\n-)\n-import (\n \t\"encoding/json\"\n-\t\"fmt\"\n \t\"os\"\n )\n \n var prt = fmt.Println\n"
                },
                {
                    "date": 1689924339993,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,9 +26,8 @@\n \n package main\n \n import (\n-\tc \"exercises/json/calculator\"\n \t\"fmt\"\n \t\"encoding/json\"\n \t\"os\"\n )\n@@ -180,11 +179,10 @@\n \t\thistory = append(history, fmt.Sprintf(\"%+v\", v))\n \t}\n \treturn history\n }\n-var prt = fmt.Println\n-var calc c.Calculator\n \n+\n func main() {\n \tprt(\"calculation with Calculator:\")\n \tprt(\"5 + 3 =\", calc.Add(5, 3))      // 8\n \tprt(\"5 - 9 =\", calc.Sub(5, 9))      // -4\n"
                },
                {
                    "date": 1689924358607,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -26,10 +26,10 @@\n \n package main\n \n import (\n+\t\"encoding/json\"\n \t\"fmt\"\n-\t\"encoding/json\"\n \t\"os\"\n )\n \n var prt = fmt.Println\n@@ -38,9 +38,9 @@\n 1. Create a MathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the calculator.\n So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n */\n \n-type MathRequest struct {\n+type mathRequest struct {\n \tNum1     int    `json:\"Num1\"`\n \tOperator string `json:\"Operator\"`\n \tNum2     int    `json:\"Num2\"`\n }\n@@ -180,9 +180,8 @@\n \t}\n \treturn history\n }\n \n-\n func main() {\n \tprt(\"calculation with Calculator:\")\n \tprt(\"5 + 3 =\", calc.Add(5, 3))      // 8\n \tprt(\"5 - 9 =\", calc.Sub(5, 9))      // -4\n"
                },
                {
                    "date": 1689924364176,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -39,10 +39,10 @@\n So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n */\n \n type mathRequest struct {\n-\tNum1     int    `json:\"Num1\"`\n-\tOperator string `json:\"Operator\"`\n+\tnum1     int    `json:\"Num1\"`\n+\toperator string `json:\"Operator\"`\n \tNum2     int    `json:\"Num2\"`\n }\n \n /*\n"
                },
                {
                    "date": 1689924386685,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,25 +49,25 @@\n 2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n */\n \n type Calculator struct {\n-\tHistory []MathRequest\n+\tHistory []mathRequest\n }\n \n func (c Calculator) Add(num1 int, num2 int) int {\n-\top := MathRequest{num1, \"Add\", num2}\n+\top := mathRequest{num1, \"Add\", num2}\n \tc.History = append(c.History, op)\n \treturn num1 + num2\n }\n \n func (c Calculator) Sub(num1 int, num2 int) int {\n-\top := MathRequest{num1, \"Sub\", num2}\n+\top := mathRequest{num1, \"Sub\", num2}\n \tc.History = append(c.History, op)\n \treturn num1 - num2\n }\n \n func (c Calculator) Mult(num1 int, num2 int) int {\n-\top := MathRequest{num1, \"Mult\", num2}\n+\top := mathRequest{num1, \"Mult\", num2}\n \tc.History = append(c.History, op)\n \treturn num1 * num2\n }\n \n@@ -75,9 +75,9 @@\n \tif num2 == 0 {\n \t\tprt(\"impossible to divide by zero\")\n \t\treturn 0\n \t}\n-\top := MathRequest{num1, \"Div\", num2}\n+\top := mathRequest{num1, \"Div\", num2}\n \tc.History = append(c.History, op)\n \treturn num1 / num2\n }\n \n"
                },
                {
                    "date": 1689924394157,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,9 +41,9 @@\n \n type mathRequest struct {\n \tnum1     int    `json:\"Num1\"`\n \toperator string `json:\"Operator\"`\n-\tNum2     int    `json:\"Num2\"`\n+\tnum2     int    `json:\"Num2\"`\n }\n \n /*\n 2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n@@ -138,18 +138,18 @@\n \t\treturn\n \t}\n \t// var data []interface{}\n \t// err = json.Unmarshal(f, &data)\n-\tmr := make([]MathRequest, 10)\n+\tmr := make([]mathRequest, 10)\n \terr = json.Unmarshal(f, &mr)\n \tif !check(err) {\n \t\treturn\n \t}\n \treturn f\n }\n \n func (c Calculator) AddToHistory(fn string) {\n-\tmr := make([]MathRequest, 10)\n+\tmr := make([]mathRequest, 10)\n \tf, err := os.ReadFile(fn)\n \tif !check(err) {\n \t\treturn\n \t}\n@@ -163,9 +163,9 @@\n \t// \tMyCalc.History[i].Num2 = mr[i].Num2\n \t// }\n \tc.History = nil\n \tfor _, mRequest := range mr {\n-\t\tc.History = append(c.History, MathRequest(mRequest))\n+\t\tc.History = append(c.History, mathRequest(mRequest))\n \t}\n \t// for i := 0; i < len(mr); i++ {\n \t// \top := MathRequest{mr[i].Num1, mr[i].Operator, mr[i].Num2}\n \t// \tMyCalc.History = append(MyCalc.History, op)\n"
                },
                {
                    "date": 1689924399861,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,9 +5,9 @@\n In this exercise we will take CalculatorA from the last exercise with the add, mult, divide, and sub functions and add some new functionality to it\n \n You might have noticed that Calculators also have some semblance of history of the operations performed - so that is what we will add\n \n-1. Create a MathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the Calculator. So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n+1. Create a mathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the Calculator. So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n \n 2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n \n 3. create an encodeHistory function this will loop over all the mathRequests in the history slice inside the CalculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax\n@@ -166,9 +166,9 @@\n \tfor _, mRequest := range mr {\n \t\tc.History = append(c.History, mathRequest(mRequest))\n \t}\n \t// for i := 0; i < len(mr); i++ {\n-\t// \top := MathRequest{mr[i].Num1, mr[i].Operator, mr[i].Num2}\n+\t// \top := mathRequest{mr[i].Num1, mr[i].Operator, mr[i].Num2}\n \t// \tMyCalc.History = append(MyCalc.History, op)\n \t// }\n \tprt(\"this is the last history:\", c.PrintHistory())\n }\n"
                },
                {
                    "date": 1689924418331,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,9 +52,9 @@\n type Calculator struct {\n \tHistory []mathRequest\n }\n \n-func (c Calculator) Add(num1 int, num2 int) int {\n+func (c Calculator) add(num1 int, num2 int) int {\n \top := mathRequest{num1, \"Add\", num2}\n \tc.History = append(c.History, op)\n \treturn num1 + num2\n }\n"
                },
                {
                    "date": 1689924424979,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,9 +53,9 @@\n \tHistory []mathRequest\n }\n \n func (c Calculator) add(num1 int, num2 int) int {\n-\top := mathRequest{num1, \"Add\", num2}\n+\top := mathRequest{num1, \"add\", num2}\n \tc.History = append(c.History, op)\n \treturn num1 + num2\n }\n \n@@ -146,9 +146,9 @@\n \t}\n \treturn f\n }\n \n-func (c Calculator) AddToHistory(fn string) {\n+func (c Calculator) addToHistory(fn string) {\n \tmr := make([]mathRequest, 10)\n \tf, err := os.ReadFile(fn)\n \tif !check(err) {\n \t\treturn\n@@ -182,19 +182,19 @@\n }\n \n func main() {\n \tprt(\"calculation with Calculator:\")\n-\tprt(\"5 + 3 =\", calc.Add(5, 3))      // 8\n+\tprt(\"5 + 3 =\", calc.add(5, 3))      // 8\n \tprt(\"5 - 9 =\", calc.Sub(5, 9))      // -4\n \tprt(\"22 * 33 =\", calc.Mult(22, 33)) // 726\n \tprt(\"4 / 0 =\", calc.Divide(4, 0))   // impossible to divide by zero\n \tprt(\"12 / 6 =\", calc.Divide(12, 6)) // 2\n \tprt()\n \t_ = calc.EncodeHistory()\n \tcalc.SaveToFile(calc.EncodeHistory(), \"test.json\")\n \t// opCalc.DecodeHistory()\n-\tHistory2 := []byte(`[{\"Num1\":6,\"Operator\":\"Add\",\"Num2\":8},{\"Num1\":2,\"Operator\":\"Sub\",\"Num2\":7},{\"Num1\":8,\"Operator\":\"Mult\",\"Num2\":8},{\"Num1\":33,\"Operator\":\"Div\",\"Num2\":11}]`)\n+\tHistory2 := []byte(`[{\"Num1\":6,\"Operator\":\"add\",\"Num2\":8},{\"Num1\":2,\"Operator\":\"Sub\",\"Num2\":7},{\"Num1\":8,\"Operator\":\"Mult\",\"Num2\":8},{\"Num1\":33,\"Operator\":\"Div\",\"Num2\":11}]`)\n \tcalc.SaveToFile(History2, \"test2.json\")\n \tcalc.DecodeHistory(\"test2.json\")\n-\tcalc.AddToHistory(\"test2.json\")\n+\tcalc.addToHistory(\"test2.json\")\n \tcalc.PrintHistory()\n }\n"
                },
                {
                    "date": 1689924444249,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -58,9 +58,9 @@\n \tc.History = append(c.History, op)\n \treturn num1 + num2\n }\n \n-func (c Calculator) Sub(num1 int, num2 int) int {\n+func (c Calculator) sub(num1 int, num2 int) int {\n \top := mathRequest{num1, \"Sub\", num2}\n \tc.History = append(c.History, op)\n \treturn num1 - num2\n }\n"
                },
                {
                    "date": 1689924464273,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,14 +59,14 @@\n \treturn num1 + num2\n }\n \n func (c Calculator) sub(num1 int, num2 int) int {\n-\top := mathRequest{num1, \"Sub\", num2}\n+\top := mathRequest{num1, \"sub\", num2}\n \tc.History = append(c.History, op)\n \treturn num1 - num2\n }\n \n-func (c Calculator) Mult(num1 int, num2 int) int {\n+func (c Calculator) mult(num1 int, num2 int) int {\n \top := mathRequest{num1, \"Mult\", num2}\n \tc.History = append(c.History, op)\n \treturn num1 * num2\n }\n@@ -183,17 +183,17 @@\n \n func main() {\n \tprt(\"calculation with Calculator:\")\n \tprt(\"5 + 3 =\", calc.add(5, 3))      // 8\n-\tprt(\"5 - 9 =\", calc.Sub(5, 9))      // -4\n+\tprt(\"5 - 9 =\", calc.sub(5, 9))      // -4\n \tprt(\"22 * 33 =\", calc.Mult(22, 33)) // 726\n \tprt(\"4 / 0 =\", calc.Divide(4, 0))   // impossible to divide by zero\n \tprt(\"12 / 6 =\", calc.Divide(12, 6)) // 2\n \tprt()\n \t_ = calc.EncodeHistory()\n \tcalc.SaveToFile(calc.EncodeHistory(), \"test.json\")\n \t// opCalc.DecodeHistory()\n-\tHistory2 := []byte(`[{\"Num1\":6,\"Operator\":\"add\",\"Num2\":8},{\"Num1\":2,\"Operator\":\"Sub\",\"Num2\":7},{\"Num1\":8,\"Operator\":\"Mult\",\"Num2\":8},{\"Num1\":33,\"Operator\":\"Div\",\"Num2\":11}]`)\n+\tHistory2 := []byte(`[{\"Num1\":6,\"Operator\":\"add\",\"Num2\":8},{\"Num1\":2,\"Operator\":\"sub\",\"Num2\":7},{\"Num1\":8,\"Operator\":\"Mult\",\"Num2\":8},{\"Num1\":33,\"Operator\":\"Div\",\"Num2\":11}]`)\n \tcalc.SaveToFile(History2, \"test2.json\")\n \tcalc.DecodeHistory(\"test2.json\")\n \tcalc.addToHistory(\"test2.json\")\n \tcalc.PrintHistory()\n"
                },
                {
                    "date": 1689924484111,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -65,14 +65,14 @@\n \treturn num1 - num2\n }\n \n func (c Calculator) mult(num1 int, num2 int) int {\n-\top := mathRequest{num1, \"Mult\", num2}\n+\top := mathRequest{num1, \"mult\", num2}\n \tc.History = append(c.History, op)\n \treturn num1 * num2\n }\n \n-func (c Calculator) Divide(num1 int, num2 int) int {\n+func (c Calculator) divide(num1 int, num2 int) int {\n \tif num2 == 0 {\n \t\tprt(\"impossible to divide by zero\")\n \t\treturn 0\n \t}\n@@ -184,16 +184,16 @@\n func main() {\n \tprt(\"calculation with Calculator:\")\n \tprt(\"5 + 3 =\", calc.add(5, 3))      // 8\n \tprt(\"5 - 9 =\", calc.sub(5, 9))      // -4\n-\tprt(\"22 * 33 =\", calc.Mult(22, 33)) // 726\n+\tprt(\"22 * 33 =\", calc.mult(22, 33)) // 726\n \tprt(\"4 / 0 =\", calc.Divide(4, 0))   // impossible to divide by zero\n \tprt(\"12 / 6 =\", calc.Divide(12, 6)) // 2\n \tprt()\n \t_ = calc.EncodeHistory()\n \tcalc.SaveToFile(calc.EncodeHistory(), \"test.json\")\n \t// opCalc.DecodeHistory()\n-\tHistory2 := []byte(`[{\"Num1\":6,\"Operator\":\"add\",\"Num2\":8},{\"Num1\":2,\"Operator\":\"sub\",\"Num2\":7},{\"Num1\":8,\"Operator\":\"Mult\",\"Num2\":8},{\"Num1\":33,\"Operator\":\"Div\",\"Num2\":11}]`)\n+\tHistory2 := []byte(`[{\"Num1\":6,\"Operator\":\"add\",\"Num2\":8},{\"Num1\":2,\"Operator\":\"sub\",\"Num2\":7},{\"Num1\":8,\"Operator\":\"mult\",\"Num2\":8},{\"Num1\":33,\"Operator\":\"Div\",\"Num2\":11}]`)\n \tcalc.SaveToFile(History2, \"test2.json\")\n \tcalc.DecodeHistory(\"test2.json\")\n \tcalc.addToHistory(\"test2.json\")\n \tcalc.PrintHistory()\n"
                },
                {
                    "date": 1689924509482,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -185,10 +185,10 @@\n \tprt(\"calculation with Calculator:\")\n \tprt(\"5 + 3 =\", calc.add(5, 3))      // 8\n \tprt(\"5 - 9 =\", calc.sub(5, 9))      // -4\n \tprt(\"22 * 33 =\", calc.mult(22, 33)) // 726\n-\tprt(\"4 / 0 =\", calc.Divide(4, 0))   // impossible to divide by zero\n-\tprt(\"12 / 6 =\", calc.Divide(12, 6)) // 2\n+\tprt(\"4 / 0 =\", calc.divide(4, 0))   // impossible to divide by zero\n+\tprt(\"12 / 6 =\", calc.divide(12, 6)) // 2\n \tprt()\n \t_ = calc.EncodeHistory()\n \tcalc.SaveToFile(calc.EncodeHistory(), \"test.json\")\n \t// opCalc.DecodeHistory()\n"
                },
                {
                    "date": 1689924543901,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,9 +48,9 @@\n /*\n 2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n */\n \n-type Calculator struct {\n+type calculator struct {\n \tHistory []mathRequest\n }\n \n func (c Calculator) add(num1 int, num2 int) int {\n"
                },
                {
                    "date": 1689924552537,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,27 +52,27 @@\n type calculator struct {\n \tHistory []mathRequest\n }\n \n-func (c Calculator) add(num1 int, num2 int) int {\n+func (c calculator) add(num1 int, num2 int) int {\n \top := mathRequest{num1, \"add\", num2}\n \tc.History = append(c.History, op)\n \treturn num1 + num2\n }\n \n-func (c Calculator) sub(num1 int, num2 int) int {\n+func (c calculator) sub(num1 int, num2 int) int {\n \top := mathRequest{num1, \"sub\", num2}\n \tc.History = append(c.History, op)\n \treturn num1 - num2\n }\n \n-func (c Calculator) mult(num1 int, num2 int) int {\n+func (c calculator) mult(num1 int, num2 int) int {\n \top := mathRequest{num1, \"mult\", num2}\n \tc.History = append(c.History, op)\n \treturn num1 * num2\n }\n \n-func (c Calculator) divide(num1 int, num2 int) int {\n+func (c calculator) divide(num1 int, num2 int) int {\n \tif num2 == 0 {\n \t\tprt(\"impossible to divide by zero\")\n \t\treturn 0\n \t}\n@@ -96,9 +96,9 @@\n \t}\n \treturn true\n }\n \n-func (c Calculator) EncodeHistory() (eh []byte) {\n+func (c calculator) EncodeHistory() (eh []byte) {\n \teh, err := json.Marshal(c.History)\n \tif !check(err) {\n \t\treturn nil\n \t}\n"
                },
                {
                    "date": 1689924557806,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -105,9 +105,9 @@\n \t// prt(\"this is returned from json converter:\", string(j))\n \treturn eh\n }\n \n-func (c Calculator) SaveToFile(eh []byte, fn string) {\n+func (c calculator) SaveToFile(eh []byte, fn string) {\n \tf, err := os.Create(fn)\n \tif !check(err) {\n \t\treturn\n \t}\n@@ -131,9 +131,9 @@\n 4. create a decodeHistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the calculator slice . At the start of this function clear out whatever was in the slice previously\n json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n */\n \n-func (c Calculator) DecodeHistory(fn string) (f []byte) {\n+func (c calculator) DecodeHistory(fn string) (f []byte) {\n \tf, err := os.ReadFile(fn)\n \tif !check(err) {\n \t\treturn\n \t}\n@@ -146,9 +146,9 @@\n \t}\n \treturn f\n }\n \n-func (c Calculator) addToHistory(fn string) {\n+func (c calculator) addToHistory(fn string) {\n \tmr := make([]mathRequest, 10)\n \tf, err := os.ReadFile(fn)\n \tif !check(err) {\n \t\treturn\n@@ -173,17 +173,17 @@\n \tprt(\"this is the last history:\", c.PrintHistory())\n }\n \n // ancillary function\n-func (c Calculator) PrintHistory() (history []string) {\n+func (c calculator) PrintHistory() (history []string) {\n \tfor _, v := range c.History {\n \t\thistory = append(history, fmt.Sprintf(\"%+v\", v))\n \t}\n \treturn history\n }\n \n func main() {\n-\tprt(\"calculation with Calculator:\")\n+\tprt(\"calculation with calculator:\")\n \tprt(\"5 + 3 =\", calc.add(5, 3))      // 8\n \tprt(\"5 - 9 =\", calc.sub(5, 9))      // -4\n \tprt(\"22 * 33 =\", calc.mult(22, 33)) // 726\n \tprt(\"4 / 0 =\", calc.divide(4, 0))   // impossible to divide by zero\n"
                },
                {
                    "date": 1689924597097,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -191,9 +191,9 @@\n \tprt()\n \t_ = calc.EncodeHistory()\n \tcalc.SaveToFile(calc.EncodeHistory(), \"test.json\")\n \t// opCalc.DecodeHistory()\n-\tHistory2 := []byte(`[{\"Num1\":6,\"Operator\":\"add\",\"Num2\":8},{\"Num1\":2,\"Operator\":\"sub\",\"Num2\":7},{\"Num1\":8,\"Operator\":\"mult\",\"Num2\":8},{\"Num1\":33,\"Operator\":\"Div\",\"Num2\":11}]`)\n+\tHistory2 := []byte(`[{\"num1\":6,\"Operator\":\"add\",\"Num2\":8},{\"num1\":2,\"Operator\":\"sub\",\"Num2\":7},{\"num1\":8,\"Operator\":\"mult\",\"Num2\":8},{\"num1\":33,\"Operator\":\"Div\",\"Num2\":11}]`)\n \tcalc.SaveToFile(History2, \"test2.json\")\n \tcalc.DecodeHistory(\"test2.json\")\n \tcalc.addToHistory(\"test2.json\")\n \tcalc.PrintHistory()\n"
                },
                {
                    "date": 1689924602691,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -39,9 +39,9 @@\n So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n */\n \n type mathRequest struct {\n-\tnum1     int    `json:\"Num1\"`\n+\tnum1     int    `json:\"num1\"`\n \toperator string `json:\"Operator\"`\n \tnum2     int    `json:\"Num2\"`\n }\n \n"
                },
                {
                    "date": 1689924613883,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,9 +41,9 @@\n \n type mathRequest struct {\n \tnum1     int    `json:\"num1\"`\n \toperator string `json:\"Operator\"`\n-\tnum2     int    `json:\"Num2\"`\n+\tnum2     int    `json:\"num2\"`\n }\n \n /*\n 2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n"
                },
                {
                    "date": 1689924626183,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -159,16 +159,16 @@\n \t}\n \t// for i := 0; i < len(mr)-1; i++ {\n \t// \tMyCalc.History[i].num1 = mr[i].num1\n \t// \tMyCalc.History[i].Operator = mr[i].Operator\n-\t// \tMyCalc.History[i].Num2 = mr[i].Num2\n+\t// \tMyCalc.History[i].num2 = mr[i].num2\n \t// }\n \tc.History = nil\n \tfor _, mRequest := range mr {\n \t\tc.History = append(c.History, mathRequest(mRequest))\n \t}\n \t// for i := 0; i < len(mr); i++ {\n-\t// \top := mathRequest{mr[i].Num1, mr[i].Operator, mr[i].Num2}\n+\t// \top := mathRequest{mr[i].Num1, mr[i].Operator, mr[i].num2}\n \t// \tMyCalc.History = append(MyCalc.History, op)\n \t// }\n \tprt(\"this is the last history:\", c.PrintHistory())\n }\n@@ -191,9 +191,9 @@\n \tprt()\n \t_ = calc.EncodeHistory()\n \tcalc.SaveToFile(calc.EncodeHistory(), \"test.json\")\n \t// opCalc.DecodeHistory()\n-\tHistory2 := []byte(`[{\"num1\":6,\"Operator\":\"add\",\"Num2\":8},{\"num1\":2,\"Operator\":\"sub\",\"Num2\":7},{\"num1\":8,\"Operator\":\"mult\",\"Num2\":8},{\"num1\":33,\"Operator\":\"Div\",\"Num2\":11}]`)\n+\tHistory2 := []byte(`[{\"num1\":6,\"Operator\":\"add\",\"num2\":8},{\"num1\":2,\"Operator\":\"sub\",\"num2\":7},{\"num1\":8,\"Operator\":\"mult\",\"num2\":8},{\"num1\":33,\"Operator\":\"Div\",\"num2\":11}]`)\n \tcalc.SaveToFile(History2, \"test2.json\")\n \tcalc.DecodeHistory(\"test2.json\")\n \tcalc.addToHistory(\"test2.json\")\n \tcalc.PrintHistory()\n"
                },
                {
                    "date": 1689924648833,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,9 +49,9 @@\n 2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n */\n \n type calculator struct {\n-\tHistory []mathRequest\n+\thistory []mathRequest\n }\n \n func (c calculator) add(num1 int, num2 int) int {\n \top := mathRequest{num1, \"add\", num2}\n"
                },
                {
                    "date": 1689924654802,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -54,21 +54,21 @@\n }\n \n func (c calculator) add(num1 int, num2 int) int {\n \top := mathRequest{num1, \"add\", num2}\n-\tc.History = append(c.History, op)\n+\tc.history = append(c.history, op)\n \treturn num1 + num2\n }\n \n func (c calculator) sub(num1 int, num2 int) int {\n \top := mathRequest{num1, \"sub\", num2}\n-\tc.History = append(c.History, op)\n+\tc.history = append(c.history, op)\n \treturn num1 - num2\n }\n \n func (c calculator) mult(num1 int, num2 int) int {\n \top := mathRequest{num1, \"mult\", num2}\n-\tc.History = append(c.History, op)\n+\tc.history = append(c.history, op)\n \treturn num1 * num2\n }\n \n func (c calculator) divide(num1 int, num2 int) int {\n@@ -76,9 +76,9 @@\n \t\tprt(\"impossible to divide by zero\")\n \t\treturn 0\n \t}\n \top := mathRequest{num1, \"Div\", num2}\n-\tc.History = append(c.History, op)\n+\tc.history = append(c.history, op)\n \treturn num1 / num2\n }\n \n /*\n"
                },
                {
                    "date": 1689924659891,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,200 @@\n+/*\n+Json allows us to serialize our data to use somewhere else\n+Serialization is also how we can 'save' our work to be used later - think saving in games and then reloading it so you dont have to start from the start\n+\n+In this exercise we will take CalculatorA from the last exercise with the add, mult, divide, and sub functions and add some new functionality to it\n+\n+You might have noticed that Calculators also have some semblance of history of the operations performed - so that is what we will add\n+\n+1. Create a mathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the Calculator. So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n+\n+2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n+\n+3. create an encodeHistory function this will loop over all the mathRequests in the history slice inside the CalculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax\n+\n+so something like this\n+\n+json.Marshal is how you convert a struct into a []byte - and then you can convert []byte into string\n+func (c Calculator) encodeHistory() []string {\n+    for _, mr := range c.history {\n+    }\n+}\n+4. create a decodeHistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the Calculator slice . At the start of this function clear out whatever was in the slice previously\n+\n+json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n+*/\n+\n+package main\n+\n+import (\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"os\"\n+)\n+\n+var prt = fmt.Println\n+\n+/*\n+1. Create a MathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the calculator.\n+So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n+*/\n+\n+type mathRequest struct {\n+\tnum1     int    `json:\"num1\"`\n+\toperator string `json:\"Operator\"`\n+\tnum2     int    `json:\"num2\"`\n+}\n+\n+/*\n+2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n+*/\n+\n+type calculator struct {\n+\thistory []mathRequest\n+}\n+\n+func (c calculator) add(num1 int, num2 int) int {\n+\top := mathRequest{num1, \"add\", num2}\n+\tc.history = append(c.history, op)\n+\treturn num1 + num2\n+}\n+\n+func (c calculator) sub(num1 int, num2 int) int {\n+\top := mathRequest{num1, \"sub\", num2}\n+\tc.history = append(c.history, op)\n+\treturn num1 - num2\n+}\n+\n+func (c calculator) mult(num1 int, num2 int) int {\n+\top := mathRequest{num1, \"mult\", num2}\n+\tc.history = append(c.history, op)\n+\treturn num1 * num2\n+}\n+\n+func (c calculator) divide(num1 int, num2 int) int {\n+\tif num2 == 0 {\n+\t\tprt(\"impossible to divide by zero\")\n+\t\treturn 0\n+\t}\n+\top := mathRequest{num1, \"Div\", num2}\n+\tc.history = append(c.history, op)\n+\treturn num1 / num2\n+}\n+\n+/*\n+3. create an encodehistory function this will loop over all the mathRequests in the history slice inside the calculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax. So something like this:\n+func (c calculator) encodeHistory() []string {\n+    for _, mr := range c.history {\n+    }\n+}\n+*/\n+\n+func check(e error) (ok bool) {\n+\tif e != nil {\n+\t\tfmt.Printf(\"Error: %s\", e.Error())\n+\t\treturn false\n+\t}\n+\treturn true\n+}\n+\n+func (c calculator) EncodeHistory() (eh []byte) {\n+\teh, err := json.Marshal(c.History)\n+\tif !check(err) {\n+\t\treturn nil\n+\t}\n+\t// prt(\"this is returned from json converter:\", string(j))\n+\treturn eh\n+}\n+\n+func (c calculator) SaveToFile(eh []byte, fn string) {\n+\tf, err := os.Create(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\tn2, err := f.Write(eh) // I should check if the file already exists but...\n+\tif !check(err) {\n+\t\tf.Close()\n+\t}\n+\tprt(n2, \"bytes written successfully\")\n+\terr = f.Close()\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\tf2, err := os.ReadFile(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\tprt(\"this is \", fn, \" file: \", string(f2))\n+}\n+\n+/*\n+4. create a decodeHistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the calculator slice . At the start of this function clear out whatever was in the slice previously\n+json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n+*/\n+\n+func (c calculator) DecodeHistory(fn string) (f []byte) {\n+\tf, err := os.ReadFile(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\t// var data []interface{}\n+\t// err = json.Unmarshal(f, &data)\n+\tmr := make([]mathRequest, 10)\n+\terr = json.Unmarshal(f, &mr)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\treturn f\n+}\n+\n+func (c calculator) addToHistory(fn string) {\n+\tmr := make([]mathRequest, 10)\n+\tf, err := os.ReadFile(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\terr = json.Unmarshal(f, &mr)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\t// for i := 0; i < len(mr)-1; i++ {\n+\t// \tMyCalc.History[i].num1 = mr[i].num1\n+\t// \tMyCalc.History[i].Operator = mr[i].Operator\n+\t// \tMyCalc.History[i].num2 = mr[i].num2\n+\t// }\n+\tc.History = nil\n+\tfor _, mRequest := range mr {\n+\t\tc.History = append(c.History, mathRequest(mRequest))\n+\t}\n+\t// for i := 0; i < len(mr); i++ {\n+\t// \top := mathRequest{mr[i].Num1, mr[i].Operator, mr[i].num2}\n+\t// \tMyCalc.History = append(MyCalc.History, op)\n+\t// }\n+\tprt(\"this is the last history:\", c.PrintHistory())\n+}\n+\n+// ancillary function\n+func (c calculator) PrintHistory() (history []string) {\n+\tfor _, v := range c.History {\n+\t\thistory = append(history, fmt.Sprintf(\"%+v\", v))\n+\t}\n+\treturn history\n+}\n+\n+func main() {\n+\tprt(\"calculation with calculator:\")\n+\tprt(\"5 + 3 =\", calc.add(5, 3))      // 8\n+\tprt(\"5 - 9 =\", calc.sub(5, 9))      // -4\n+\tprt(\"22 * 33 =\", calc.mult(22, 33)) // 726\n+\tprt(\"4 / 0 =\", calc.divide(4, 0))   // impossible to divide by zero\n+\tprt(\"12 / 6 =\", calc.divide(12, 6)) // 2\n+\tprt()\n+\t_ = calc.EncodeHistory()\n+\tcalc.SaveToFile(calc.EncodeHistory(), \"test.json\")\n+\t// opCalc.DecodeHistory()\n+\tHistory2 := []byte(`[{\"num1\":6,\"Operator\":\"add\",\"num2\":8},{\"num1\":2,\"Operator\":\"sub\",\"num2\":7},{\"num1\":8,\"Operator\":\"mult\",\"num2\":8},{\"num1\":33,\"Operator\":\"Div\",\"num2\":11}]`)\n+\tcalc.SaveToFile(History2, \"test2.json\")\n+\tcalc.DecodeHistory(\"test2.json\")\n+\tcalc.addToHistory(\"test2.json\")\n+\tcalc.PrintHistory()\n+}\n"
                },
                {
                    "date": 1689924665588,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -82,9 +82,9 @@\n }\n \n /*\n 3. create an encodehistory function this will loop over all the mathRequests in the history slice inside the calculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax. So something like this:\n-func (c calculator) encodeHistory() []string {\n+func (c calculator) encodehistory() []string {\n     for _, mr := range c.history {\n     }\n }\n */\n@@ -197,204 +197,4 @@\n \tcalc.DecodeHistory(\"test2.json\")\n \tcalc.addToHistory(\"test2.json\")\n \tcalc.PrintHistory()\n }\n-/*\n-Json allows us to serialize our data to use somewhere else\n-Serialization is also how we can 'save' our work to be used later - think saving in games and then reloading it so you dont have to start from the start\n-\n-In this exercise we will take CalculatorA from the last exercise with the add, mult, divide, and sub functions and add some new functionality to it\n-\n-You might have noticed that Calculators also have some semblance of history of the operations performed - so that is what we will add\n-\n-1. Create a mathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the Calculator. So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n-\n-2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n-\n-3. create an encodeHistory function this will loop over all the mathRequests in the history slice inside the CalculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax\n-\n-so something like this\n-\n-json.Marshal is how you convert a struct into a []byte - and then you can convert []byte into string\n-func (c Calculator) encodeHistory() []string {\n-    for _, mr := range c.history {\n-    }\n-}\n-4. create a decodeHistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the Calculator slice . At the start of this function clear out whatever was in the slice previously\n-\n-json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n-*/\n-\n-package main\n-\n-import (\n-\t\"encoding/json\"\n-\t\"fmt\"\n-\t\"os\"\n-)\n-\n-var prt = fmt.Println\n-\n-/*\n-1. Create a MathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the calculator.\n-So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n-*/\n-\n-type mathRequest struct {\n-\tnum1     int    `json:\"num1\"`\n-\toperator string `json:\"Operator\"`\n-\tnum2     int    `json:\"num2\"`\n-}\n-\n-/*\n-2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n-*/\n-\n-type calculator struct {\n-\thistory []mathRequest\n-}\n-\n-func (c calculator) add(num1 int, num2 int) int {\n-\top := mathRequest{num1, \"add\", num2}\n-\tc.history = append(c.history, op)\n-\treturn num1 + num2\n-}\n-\n-func (c calculator) sub(num1 int, num2 int) int {\n-\top := mathRequest{num1, \"sub\", num2}\n-\tc.history = append(c.history, op)\n-\treturn num1 - num2\n-}\n-\n-func (c calculator) mult(num1 int, num2 int) int {\n-\top := mathRequest{num1, \"mult\", num2}\n-\tc.history = append(c.history, op)\n-\treturn num1 * num2\n-}\n-\n-func (c calculator) divide(num1 int, num2 int) int {\n-\tif num2 == 0 {\n-\t\tprt(\"impossible to divide by zero\")\n-\t\treturn 0\n-\t}\n-\top := mathRequest{num1, \"Div\", num2}\n-\tc.history = append(c.history, op)\n-\treturn num1 / num2\n-}\n-\n-/*\n-3. create an encodeHistory function this will loop over all the mathRequests in the history slice inside the calculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax. So something like this:\n-func (c calculator) encodeHistory() []string {\n-    for _, mr := range c.history {\n-    }\n-}\n-*/\n-\n-func check(e error) (ok bool) {\n-\tif e != nil {\n-\t\tfmt.Printf(\"Error: %s\", e.Error())\n-\t\treturn false\n-\t}\n-\treturn true\n-}\n-\n-func (c calculator) EncodeHistory() (eh []byte) {\n-\teh, err := json.Marshal(c.History)\n-\tif !check(err) {\n-\t\treturn nil\n-\t}\n-\t// prt(\"this is returned from json converter:\", string(j))\n-\treturn eh\n-}\n-\n-func (c calculator) SaveToFile(eh []byte, fn string) {\n-\tf, err := os.Create(fn)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\tn2, err := f.Write(eh) // I should check if the file already exists but...\n-\tif !check(err) {\n-\t\tf.Close()\n-\t}\n-\tprt(n2, \"bytes written successfully\")\n-\terr = f.Close()\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\tf2, err := os.ReadFile(fn)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\tprt(\"this is \", fn, \" file: \", string(f2))\n-}\n-\n-/*\n-4. create a decodeHistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the calculator slice . At the start of this function clear out whatever was in the slice previously\n-json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n-*/\n-\n-func (c calculator) DecodeHistory(fn string) (f []byte) {\n-\tf, err := os.ReadFile(fn)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\t// var data []interface{}\n-\t// err = json.Unmarshal(f, &data)\n-\tmr := make([]mathRequest, 10)\n-\terr = json.Unmarshal(f, &mr)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\treturn f\n-}\n-\n-func (c calculator) addToHistory(fn string) {\n-\tmr := make([]mathRequest, 10)\n-\tf, err := os.ReadFile(fn)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\terr = json.Unmarshal(f, &mr)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\t// for i := 0; i < len(mr)-1; i++ {\n-\t// \tMyCalc.History[i].num1 = mr[i].num1\n-\t// \tMyCalc.History[i].Operator = mr[i].Operator\n-\t// \tMyCalc.History[i].num2 = mr[i].num2\n-\t// }\n-\tc.History = nil\n-\tfor _, mRequest := range mr {\n-\t\tc.History = append(c.History, mathRequest(mRequest))\n-\t}\n-\t// for i := 0; i < len(mr); i++ {\n-\t// \top := mathRequest{mr[i].Num1, mr[i].Operator, mr[i].num2}\n-\t// \tMyCalc.History = append(MyCalc.History, op)\n-\t// }\n-\tprt(\"this is the last history:\", c.PrintHistory())\n-}\n-\n-// ancillary function\n-func (c calculator) PrintHistory() (history []string) {\n-\tfor _, v := range c.History {\n-\t\thistory = append(history, fmt.Sprintf(\"%+v\", v))\n-\t}\n-\treturn history\n-}\n-\n-func main() {\n-\tprt(\"calculation with calculator:\")\n-\tprt(\"5 + 3 =\", calc.add(5, 3))      // 8\n-\tprt(\"5 - 9 =\", calc.sub(5, 9))      // -4\n-\tprt(\"22 * 33 =\", calc.mult(22, 33)) // 726\n-\tprt(\"4 / 0 =\", calc.divide(4, 0))   // impossible to divide by zero\n-\tprt(\"12 / 6 =\", calc.divide(12, 6)) // 2\n-\tprt()\n-\t_ = calc.EncodeHistory()\n-\tcalc.SaveToFile(calc.EncodeHistory(), \"test.json\")\n-\t// opCalc.DecodeHistory()\n-\tHistory2 := []byte(`[{\"num1\":6,\"Operator\":\"add\",\"num2\":8},{\"num1\":2,\"Operator\":\"sub\",\"num2\":7},{\"num1\":8,\"Operator\":\"mult\",\"num2\":8},{\"num1\":33,\"Operator\":\"Div\",\"num2\":11}]`)\n-\tcalc.SaveToFile(History2, \"test2.json\")\n-\tcalc.DecodeHistory(\"test2.json\")\n-\tcalc.addToHistory(\"test2.json\")\n-\tcalc.PrintHistory()\n-}\n"
                },
                {
                    "date": 1689924671154,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -97,9 +97,9 @@\n \treturn true\n }\n \n func (c calculator) EncodeHistory() (eh []byte) {\n-\teh, err := json.Marshal(c.History)\n+\teh, err := json.Marshal(c.history)\n \tif !check(err) {\n \t\treturn nil\n \t}\n \t// prt(\"this is returned from json converter:\", string(j))\n"
                },
                {
                    "date": 1689924678724,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -127,9 +127,9 @@\n \tprt(\"this is \", fn, \" file: \", string(f2))\n }\n \n /*\n-4. create a decodeHistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the calculator slice . At the start of this function clear out whatever was in the slice previously\n+4. create a decodehistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the calculator slice . At the start of this function clear out whatever was in the slice previously\n json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n */\n \n func (c calculator) DecodeHistory(fn string) (f []byte) {\n"
                },
                {
                    "date": 1689924686313,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -157,11 +157,11 @@\n \tif !check(err) {\n \t\treturn\n \t}\n \t// for i := 0; i < len(mr)-1; i++ {\n-\t// \tMyCalc.History[i].num1 = mr[i].num1\n-\t// \tMyCalc.History[i].Operator = mr[i].Operator\n-\t// \tMyCalc.History[i].num2 = mr[i].num2\n+\t// \tMyCalc.history[i].num1 = mr[i].num1\n+\t// \tMyCalc.history[i].Operator = mr[i].Operator\n+\t// \tMyCalc.history[i].num2 = mr[i].num2\n \t// }\n \tc.History = nil\n \tfor _, mRequest := range mr {\n \t\tc.History = append(c.History, mathRequest(mRequest))\n"
                },
                {
                    "date": 1689924708212,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -161,22 +161,22 @@\n \t// \tMyCalc.history[i].num1 = mr[i].num1\n \t// \tMyCalc.history[i].Operator = mr[i].Operator\n \t// \tMyCalc.history[i].num2 = mr[i].num2\n \t// }\n-\tc.History = nil\n+\tc.history = nil\n \tfor _, mRequest := range mr {\n-\t\tc.History = append(c.History, mathRequest(mRequest))\n+\t\tc.history = append(c.history, mathRequest(mRequest))\n \t}\n \t// for i := 0; i < len(mr); i++ {\n \t// \top := mathRequest{mr[i].Num1, mr[i].Operator, mr[i].num2}\n-\t// \tMyCalc.History = append(MyCalc.History, op)\n+\t// \tMyCalc.history = append(MyCalc.history, op)\n \t// }\n \tprt(\"this is the last history:\", c.PrintHistory())\n }\n \n // ancillary function\n func (c calculator) PrintHistory() (history []string) {\n-\tfor _, v := range c.History {\n+\tfor _, v := range c.history {\n \t\thistory = append(history, fmt.Sprintf(\"%+v\", v))\n \t}\n \treturn history\n }\n"
                },
                {
                    "date": 1689924721052,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,200 @@\n+/*\n+Json allows us to serialize our data to use somewhere else\n+Serialization is also how we can 'save' our work to be used later - think saving in games and then reloading it so you dont have to start from the start\n+\n+In this exercise we will take CalculatorA from the last exercise with the add, mult, divide, and sub functions and add some new functionality to it\n+\n+You might have noticed that Calculators also have some semblance of history of the operations performed - so that is what we will add\n+\n+1. Create a mathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the Calculator. So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n+\n+2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n+\n+3. create an encodeHistory function this will loop over all the mathRequests in the history slice inside the CalculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax\n+\n+so something like this\n+\n+json.Marshal is how you convert a struct into a []byte - and then you can convert []byte into string\n+func (c Calculator) encodeHistory() []string {\n+    for _, mr := range c.history {\n+    }\n+}\n+4. create a decodeHistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the Calculator slice . At the start of this function clear out whatever was in the slice previously\n+\n+json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n+*/\n+\n+package main\n+\n+import (\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"os\"\n+)\n+\n+var prt = fmt.Println\n+\n+/*\n+1. Create a MathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the calculator.\n+So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n+*/\n+\n+type mathRequest struct {\n+\tnum1     int    `json:\"num1\"`\n+\toperator string `json:\"Operator\"`\n+\tnum2     int    `json:\"num2\"`\n+}\n+\n+/*\n+2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n+*/\n+\n+type calculator struct {\n+\thistory []mathRequest\n+}\n+\n+func (c calculator) add(num1 int, num2 int) int {\n+\top := mathRequest{num1, \"add\", num2}\n+\tc.history = append(c.history, op)\n+\treturn num1 + num2\n+}\n+\n+func (c calculator) sub(num1 int, num2 int) int {\n+\top := mathRequest{num1, \"sub\", num2}\n+\tc.history = append(c.history, op)\n+\treturn num1 - num2\n+}\n+\n+func (c calculator) mult(num1 int, num2 int) int {\n+\top := mathRequest{num1, \"mult\", num2}\n+\tc.history = append(c.history, op)\n+\treturn num1 * num2\n+}\n+\n+func (c calculator) divide(num1 int, num2 int) int {\n+\tif num2 == 0 {\n+\t\tprt(\"impossible to divide by zero\")\n+\t\treturn 0\n+\t}\n+\top := mathRequest{num1, \"Div\", num2}\n+\tc.history = append(c.history, op)\n+\treturn num1 / num2\n+}\n+\n+/*\n+3. create an encodehistory function this will loop over all the mathRequests in the history slice inside the calculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax. So something like this:\n+func (c calculator) encodehistory() []string {\n+    for _, mr := range c.history {\n+    }\n+}\n+*/\n+\n+func check(e error) (ok bool) {\n+\tif e != nil {\n+\t\tfmt.Printf(\"Error: %s\", e.Error())\n+\t\treturn false\n+\t}\n+\treturn true\n+}\n+\n+func (c calculator) EncodeHistory() (eh []byte) {\n+\teh, err := json.Marshal(c.history)\n+\tif !check(err) {\n+\t\treturn nil\n+\t}\n+\t// prt(\"this is returned from json converter:\", string(j))\n+\treturn eh\n+}\n+\n+func (c calculator) SaveToFile(eh []byte, fn string) {\n+\tf, err := os.Create(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\tn2, err := f.Write(eh) // I should check if the file already exists but...\n+\tif !check(err) {\n+\t\tf.Close()\n+\t}\n+\tprt(n2, \"bytes written successfully\")\n+\terr = f.Close()\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\tf2, err := os.ReadFile(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\tprt(\"this is \", fn, \" file: \", string(f2))\n+}\n+\n+/*\n+4. create a decodehistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the calculator slice . At the start of this function clear out whatever was in the slice previously\n+json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n+*/\n+\n+func (c calculator) DecodeHistory(fn string) (f []byte) {\n+\tf, err := os.ReadFile(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\t// var data []interface{}\n+\t// err = json.Unmarshal(f, &data)\n+\tmr := make([]mathRequest, 10)\n+\terr = json.Unmarshal(f, &mr)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\treturn f\n+}\n+\n+func (c calculator) addToHistory(fn string) {\n+\tmr := make([]mathRequest, 10)\n+\tf, err := os.ReadFile(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\terr = json.Unmarshal(f, &mr)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\t// for i := 0; i < len(mr)-1; i++ {\n+\t// \tMyCalc.history[i].num1 = mr[i].num1\n+\t// \tMyCalc.history[i].Operator = mr[i].Operator\n+\t// \tMyCalc.history[i].num2 = mr[i].num2\n+\t// }\n+\tc.history = nil\n+\tfor _, mRequest := range mr {\n+\t\tc.history = append(c.history, mathRequest(mRequest))\n+\t}\n+\t// for i := 0; i < len(mr); i++ {\n+\t// \top := mathRequest{mr[i].Num1, mr[i].Operator, mr[i].num2}\n+\t// \tMyCalc.history = append(MyCalc.history, op)\n+\t// }\n+\tprt(\"this is the last history:\", c.PrintHistory())\n+}\n+\n+// ancillary function\n+func (c calculator) PrintHistory() (history []string) {\n+\tfor _, v := range c.history {\n+\t\thistory = append(history, fmt.Sprintf(\"%+v\", v))\n+\t}\n+\treturn history\n+}\n+\n+func main() {\n+\tprt(\"calculation with calculator:\")\n+\tprt(\"5 + 3 =\", calc.add(5, 3))      // 8\n+\tprt(\"5 - 9 =\", calc.sub(5, 9))      // -4\n+\tprt(\"22 * 33 =\", calc.mult(22, 33)) // 726\n+\tprt(\"4 / 0 =\", calc.divide(4, 0))   // impossible to divide by zero\n+\tprt(\"12 / 6 =\", calc.divide(12, 6)) // 2\n+\tprt()\n+\t_ = calc.EncodeHistory()\n+\tcalc.SaveToFile(calc.EncodeHistory(), \"test.json\")\n+\t// opCalc.DecodeHistory()\n+\thistory2 := []byte(`[{\"num1\":6,\"Operator\":\"add\",\"num2\":8},{\"num1\":2,\"Operator\":\"sub\",\"num2\":7},{\"num1\":8,\"Operator\":\"mult\",\"num2\":8},{\"num1\":33,\"Operator\":\"Div\",\"num2\":11}]`)\n+\tcalc.SaveToFile(History2, \"test2.json\")\n+\tcalc.DecodeHistory(\"test2.json\")\n+\tcalc.addToHistory(\"test2.json\")\n+\tcalc.PrintHistory()\n+}\n"
                },
                {
                    "date": 1689924755267,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -96,9 +96,9 @@\n \t}\n \treturn true\n }\n \n-func (c calculator) EncodeHistory() (eh []byte) {\n+func (c calculator) encodeHistory() (eh []byte) {\n \teh, err := json.Marshal(c.history)\n \tif !check(err) {\n \t\treturn nil\n \t}\n@@ -192,209 +192,9 @@\n \t_ = calc.EncodeHistory()\n \tcalc.SaveToFile(calc.EncodeHistory(), \"test.json\")\n \t// opCalc.DecodeHistory()\n \thistory2 := []byte(`[{\"num1\":6,\"Operator\":\"add\",\"num2\":8},{\"num1\":2,\"Operator\":\"sub\",\"num2\":7},{\"num1\":8,\"Operator\":\"mult\",\"num2\":8},{\"num1\":33,\"Operator\":\"Div\",\"num2\":11}]`)\n-\tcalc.SaveToFile(History2, \"test2.json\")\n+\tcalc.SaveToFile(history2, \"test2.json\")\n \tcalc.DecodeHistory(\"test2.json\")\n \tcalc.addToHistory(\"test2.json\")\n \tcalc.PrintHistory()\n }\n-/*\n-Json allows us to serialize our data to use somewhere else\n-Serialization is also how we can 'save' our work to be used later - think saving in games and then reloading it so you dont have to start from the start\n-\n-In this exercise we will take CalculatorA from the last exercise with the add, mult, divide, and sub functions and add some new functionality to it\n-\n-You might have noticed that Calculators also have some semblance of history of the operations performed - so that is what we will add\n-\n-1. Create a mathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the Calculator. So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n-\n-2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n-\n-3. create an encodeHistory function this will loop over all the mathRequests in the history slice inside the CalculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax\n-\n-so something like this\n-\n-json.Marshal is how you convert a struct into a []byte - and then you can convert []byte into string\n-func (c Calculator) encodeHistory() []string {\n-    for _, mr := range c.history {\n-    }\n-}\n-4. create a decodeHistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the Calculator slice . At the start of this function clear out whatever was in the slice previously\n-\n-json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n-*/\n-\n-package main\n-\n-import (\n-\t\"encoding/json\"\n-\t\"fmt\"\n-\t\"os\"\n-)\n-\n-var prt = fmt.Println\n-\n-/*\n-1. Create a MathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the calculator.\n-So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n-*/\n-\n-type mathRequest struct {\n-\tnum1     int    `json:\"num1\"`\n-\toperator string `json:\"Operator\"`\n-\tnum2     int    `json:\"num2\"`\n-}\n-\n-/*\n-2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n-*/\n-\n-type calculator struct {\n-\thistory []mathRequest\n-}\n-\n-func (c calculator) add(num1 int, num2 int) int {\n-\top := mathRequest{num1, \"add\", num2}\n-\tc.history = append(c.history, op)\n-\treturn num1 + num2\n-}\n-\n-func (c calculator) sub(num1 int, num2 int) int {\n-\top := mathRequest{num1, \"sub\", num2}\n-\tc.history = append(c.history, op)\n-\treturn num1 - num2\n-}\n-\n-func (c calculator) mult(num1 int, num2 int) int {\n-\top := mathRequest{num1, \"mult\", num2}\n-\tc.history = append(c.history, op)\n-\treturn num1 * num2\n-}\n-\n-func (c calculator) divide(num1 int, num2 int) int {\n-\tif num2 == 0 {\n-\t\tprt(\"impossible to divide by zero\")\n-\t\treturn 0\n-\t}\n-\top := mathRequest{num1, \"Div\", num2}\n-\tc.history = append(c.history, op)\n-\treturn num1 / num2\n-}\n-\n-/*\n-3. create an encodehistory function this will loop over all the mathRequests in the history slice inside the calculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax. So something like this:\n-func (c calculator) encodehistory() []string {\n-    for _, mr := range c.history {\n-    }\n-}\n-*/\n-\n-func check(e error) (ok bool) {\n-\tif e != nil {\n-\t\tfmt.Printf(\"Error: %s\", e.Error())\n-\t\treturn false\n-\t}\n-\treturn true\n-}\n-\n-func (c calculator) EncodeHistory() (eh []byte) {\n-\teh, err := json.Marshal(c.history)\n-\tif !check(err) {\n-\t\treturn nil\n-\t}\n-\t// prt(\"this is returned from json converter:\", string(j))\n-\treturn eh\n-}\n-\n-func (c calculator) SaveToFile(eh []byte, fn string) {\n-\tf, err := os.Create(fn)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\tn2, err := f.Write(eh) // I should check if the file already exists but...\n-\tif !check(err) {\n-\t\tf.Close()\n-\t}\n-\tprt(n2, \"bytes written successfully\")\n-\terr = f.Close()\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\tf2, err := os.ReadFile(fn)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\tprt(\"this is \", fn, \" file: \", string(f2))\n-}\n-\n-/*\n-4. create a decodehistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the calculator slice . At the start of this function clear out whatever was in the slice previously\n-json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n-*/\n-\n-func (c calculator) DecodeHistory(fn string) (f []byte) {\n-\tf, err := os.ReadFile(fn)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\t// var data []interface{}\n-\t// err = json.Unmarshal(f, &data)\n-\tmr := make([]mathRequest, 10)\n-\terr = json.Unmarshal(f, &mr)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\treturn f\n-}\n-\n-func (c calculator) addToHistory(fn string) {\n-\tmr := make([]mathRequest, 10)\n-\tf, err := os.ReadFile(fn)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\terr = json.Unmarshal(f, &mr)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\t// for i := 0; i < len(mr)-1; i++ {\n-\t// \tMyCalc.history[i].num1 = mr[i].num1\n-\t// \tMyCalc.history[i].Operator = mr[i].Operator\n-\t// \tMyCalc.history[i].num2 = mr[i].num2\n-\t// }\n-\tc.history = nil\n-\tfor _, mRequest := range mr {\n-\t\tc.history = append(c.history, mathRequest(mRequest))\n-\t}\n-\t// for i := 0; i < len(mr); i++ {\n-\t// \top := mathRequest{mr[i].Num1, mr[i].Operator, mr[i].num2}\n-\t// \tMyCalc.history = append(MyCalc.history, op)\n-\t// }\n-\tprt(\"this is the last history:\", c.PrintHistory())\n-}\n-\n-// ancillary function\n-func (c calculator) PrintHistory() (history []string) {\n-\tfor _, v := range c.history {\n-\t\thistory = append(history, fmt.Sprintf(\"%+v\", v))\n-\t}\n-\treturn history\n-}\n-\n-func main() {\n-\tprt(\"calculation with calculator:\")\n-\tprt(\"5 + 3 =\", calc.add(5, 3))      // 8\n-\tprt(\"5 - 9 =\", calc.sub(5, 9))      // -4\n-\tprt(\"22 * 33 =\", calc.mult(22, 33)) // 726\n-\tprt(\"4 / 0 =\", calc.divide(4, 0))   // impossible to divide by zero\n-\tprt(\"12 / 6 =\", calc.divide(12, 6)) // 2\n-\tprt()\n-\t_ = calc.EncodeHistory()\n-\tcalc.SaveToFile(calc.EncodeHistory(), \"test.json\")\n-\t// opCalc.DecodeHistory()\n-\tHistory2 := []byte(`[{\"num1\":6,\"Operator\":\"add\",\"num2\":8},{\"num1\":2,\"Operator\":\"sub\",\"num2\":7},{\"num1\":8,\"Operator\":\"mult\",\"num2\":8},{\"num1\":33,\"Operator\":\"Div\",\"num2\":11}]`)\n-\tcalc.SaveToFile(History2, \"test2.json\")\n-\tcalc.DecodeHistory(\"test2.json\")\n-\tcalc.addToHistory(\"test2.json\")\n-\tcalc.PrintHistory()\n-}\n"
                },
                {
                    "date": 1689924787325,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -188,10 +188,10 @@\n \tprt(\"22 * 33 =\", calc.mult(22, 33)) // 726\n \tprt(\"4 / 0 =\", calc.divide(4, 0))   // impossible to divide by zero\n \tprt(\"12 / 6 =\", calc.divide(12, 6)) // 2\n \tprt()\n-\t_ = calc.EncodeHistory()\n-\tcalc.SaveToFile(calc.EncodeHistory(), \"test.json\")\n+\t_ = calc.encodeHistory()\n+\tcalc.saveToFile(calc.encodeHistory(), \"test.json\")\n \t// opCalc.DecodeHistory()\n \thistory2 := []byte(`[{\"num1\":6,\"Operator\":\"add\",\"num2\":8},{\"num1\":2,\"Operator\":\"sub\",\"num2\":7},{\"num1\":8,\"Operator\":\"mult\",\"num2\":8},{\"num1\":33,\"Operator\":\"Div\",\"num2\":11}]`)\n \tcalc.SaveToFile(history2, \"test2.json\")\n \tcalc.DecodeHistory(\"test2.json\")\n"
                },
                {
                    "date": 1689924807469,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -105,9 +105,9 @@\n \t// prt(\"this is returned from json converter:\", string(j))\n \treturn eh\n }\n \n-func (c calculator) SaveToFile(eh []byte, fn string) {\n+func (c calculator) saveToFile(eh []byte, fn string) {\n \tf, err := os.Create(fn)\n \tif !check(err) {\n \t\treturn\n \t}\n@@ -131,9 +131,9 @@\n 4. create a decodehistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the calculator slice . At the start of this function clear out whatever was in the slice previously\n json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n */\n \n-func (c calculator) DecodeHistory(fn string) (f []byte) {\n+func (c calculator) decodeHistory(fn string) (f []byte) {\n \tf, err := os.ReadFile(fn)\n \tif !check(err) {\n \t\treturn\n \t}\n@@ -190,11 +190,11 @@\n \tprt(\"12 / 6 =\", calc.divide(12, 6)) // 2\n \tprt()\n \t_ = calc.encodeHistory()\n \tcalc.saveToFile(calc.encodeHistory(), \"test.json\")\n-\t// opCalc.DecodeHistory()\n+\t// opCalc.decodeHistory()\n \thistory2 := []byte(`[{\"num1\":6,\"Operator\":\"add\",\"num2\":8},{\"num1\":2,\"Operator\":\"sub\",\"num2\":7},{\"num1\":8,\"Operator\":\"mult\",\"num2\":8},{\"num1\":33,\"Operator\":\"Div\",\"num2\":11}]`)\n-\tcalc.SaveToFile(history2, \"test2.json\")\n-\tcalc.DecodeHistory(\"test2.json\")\n+\tcalc.saveToFile(history2, \"test2.json\")\n+\tcalc.decodeHistory(\"test2.json\")\n \tcalc.addToHistory(\"test2.json\")\n \tcalc.PrintHistory()\n }\n"
                },
                {
                    "date": 1689924823040,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -169,9 +169,9 @@\n \t// for i := 0; i < len(mr); i++ {\n \t// \top := mathRequest{mr[i].Num1, mr[i].Operator, mr[i].num2}\n \t// \tMyCalc.history = append(MyCalc.history, op)\n \t// }\n-\tprt(\"this is the last history:\", c.PrintHistory())\n+\tprt(\"this is the last history:\", c.printHistory())\n }\n \n // ancillary function\n func (c calculator) PrintHistory() (history []string) {\n"
                },
                {
                    "date": 1689924864653,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -156,13 +156,9 @@\n \terr = json.Unmarshal(f, &mr)\n \tif !check(err) {\n \t\treturn\n \t}\n-\t// for i := 0; i < len(mr)-1; i++ {\n-\t// \tMyCalc.history[i].num1 = mr[i].num1\n-\t// \tMyCalc.history[i].Operator = mr[i].Operator\n-\t// \tMyCalc.history[i].num2 = mr[i].num2\n-\t// }\n+\n \tc.history = nil\n \tfor _, mRequest := range mr {\n \t\tc.history = append(c.history, mathRequest(mRequest))\n \t}\n@@ -173,9 +169,9 @@\n \tprt(\"this is the last history:\", c.printHistory())\n }\n \n // ancillary function\n-func (c calculator) PrintHistory() (history []string) {\n+func (c calculator) printHistory() (history []string) {\n \tfor _, v := range c.history {\n \t\thistory = append(history, fmt.Sprintf(\"%+v\", v))\n \t}\n \treturn history\n@@ -195,6 +191,6 @@\n \thistory2 := []byte(`[{\"num1\":6,\"Operator\":\"add\",\"num2\":8},{\"num1\":2,\"Operator\":\"sub\",\"num2\":7},{\"num1\":8,\"Operator\":\"mult\",\"num2\":8},{\"num1\":33,\"Operator\":\"Div\",\"num2\":11}]`)\n \tcalc.saveToFile(history2, \"test2.json\")\n \tcalc.decodeHistory(\"test2.json\")\n \tcalc.addToHistory(\"test2.json\")\n-\tcalc.PrintHistory()\n+\tcalc.printHistory()\n }\n"
                },
                {
                    "date": 1689924875241,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -161,12 +161,8 @@\n \tc.history = nil\n \tfor _, mRequest := range mr {\n \t\tc.history = append(c.history, mathRequest(mRequest))\n \t}\n-\t// for i := 0; i < len(mr); i++ {\n-\t// \top := mathRequest{mr[i].Num1, mr[i].Operator, mr[i].num2}\n-\t// \tMyCalc.history = append(MyCalc.history, op)\n-\t// }\n \tprt(\"this is the last history:\", c.printHistory())\n }\n \n // ancillary function\n"
                },
                {
                    "date": 1689924884853,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -174,9 +174,9 @@\n }\n \n func main() {\n \tprt(\"calculation with calculator:\")\n-\tprt(\"5 + 3 =\", calc.add(5, 3))      // 8\n+\tprt(\"5 + 3 =\", calculator.add(5, 3))      // 8\n \tprt(\"5 - 9 =\", calc.sub(5, 9))      // -4\n \tprt(\"22 * 33 =\", calc.mult(22, 33)) // 726\n \tprt(\"4 / 0 =\", calc.divide(4, 0))   // impossible to divide by zero\n \tprt(\"12 / 6 =\", calc.divide(12, 6)) // 2\n"
                },
                {
                    "date": 1689924894167,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -175,12 +175,12 @@\n \n func main() {\n \tprt(\"calculation with calculator:\")\n \tprt(\"5 + 3 =\", calculator.add(5, 3))      // 8\n-\tprt(\"5 - 9 =\", calc.sub(5, 9))      // -4\n-\tprt(\"22 * 33 =\", calc.mult(22, 33)) // 726\n-\tprt(\"4 / 0 =\", calc.divide(4, 0))   // impossible to divide by zero\n-\tprt(\"12 / 6 =\", calc.divide(12, 6)) // 2\n+\tprt(\"5 - 9 =\", calculator.sub(5, 9))      // -4\n+\tprt(\"22 * 33 =\", calculator.mult(22, 33)) // 726\n+\tprt(\"4 / 0 =\", calculator.divide(4, 0))   // impossible to divide by zero\n+\tprt(\"12 / 6 =\", calculator.divide(12, 6)) // 2\n \tprt()\n \t_ = calc.encodeHistory()\n \tcalc.saveToFile(calc.encodeHistory(), \"test.json\")\n \t// opCalc.decodeHistory()\n"
                },
                {
                    "date": 1689924902733,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,192 @@\n+/*\n+Json allows us to serialize our data to use somewhere else\n+Serialization is also how we can 'save' our work to be used later - think saving in games and then reloading it so you dont have to start from the start\n+\n+In this exercise we will take CalculatorA from the last exercise with the add, mult, divide, and sub functions and add some new functionality to it\n+\n+You might have noticed that Calculators also have some semblance of history of the operations performed - so that is what we will add\n+\n+1. Create a mathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the Calculator. So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n+\n+2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n+\n+3. create an encodeHistory function this will loop over all the mathRequests in the history slice inside the CalculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax\n+\n+so something like this\n+\n+json.Marshal is how you convert a struct into a []byte - and then you can convert []byte into string\n+func (c Calculator) encodeHistory() []string {\n+    for _, mr := range c.history {\n+    }\n+}\n+4. create a decodeHistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the Calculator slice . At the start of this function clear out whatever was in the slice previously\n+\n+json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n+*/\n+\n+package main\n+\n+import (\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"os\"\n+)\n+\n+var prt = fmt.Println\n+\n+/*\n+1. Create a MathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the calculator.\n+So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n+*/\n+\n+type mathRequest struct {\n+\tnum1     int    `json:\"num1\"`\n+\toperator string `json:\"Operator\"`\n+\tnum2     int    `json:\"num2\"`\n+}\n+\n+/*\n+2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n+*/\n+\n+type calculator struct {\n+\thistory []mathRequest\n+}\n+\n+func (c calculator) add(num1 int, num2 int) int {\n+\top := mathRequest{num1, \"add\", num2}\n+\tc.history = append(c.history, op)\n+\treturn num1 + num2\n+}\n+\n+func (c calculator) sub(num1 int, num2 int) int {\n+\top := mathRequest{num1, \"sub\", num2}\n+\tc.history = append(c.history, op)\n+\treturn num1 - num2\n+}\n+\n+func (c calculator) mult(num1 int, num2 int) int {\n+\top := mathRequest{num1, \"mult\", num2}\n+\tc.history = append(c.history, op)\n+\treturn num1 * num2\n+}\n+\n+func (c calculator) divide(num1 int, num2 int) int {\n+\tif num2 == 0 {\n+\t\tprt(\"impossible to divide by zero\")\n+\t\treturn 0\n+\t}\n+\top := mathRequest{num1, \"Div\", num2}\n+\tc.history = append(c.history, op)\n+\treturn num1 / num2\n+}\n+\n+/*\n+3. create an encodehistory function this will loop over all the mathRequests in the history slice inside the calculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax. So something like this:\n+func (c calculator) encodehistory() []string {\n+    for _, mr := range c.history {\n+    }\n+}\n+*/\n+\n+func check(e error) (ok bool) {\n+\tif e != nil {\n+\t\tfmt.Printf(\"Error: %s\", e.Error())\n+\t\treturn false\n+\t}\n+\treturn true\n+}\n+\n+func (c calculator) encodeHistory() (eh []byte) {\n+\teh, err := json.Marshal(c.history)\n+\tif !check(err) {\n+\t\treturn nil\n+\t}\n+\t// prt(\"this is returned from json converter:\", string(j))\n+\treturn eh\n+}\n+\n+func (c calculator) saveToFile(eh []byte, fn string) {\n+\tf, err := os.Create(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\tn2, err := f.Write(eh) // I should check if the file already exists but...\n+\tif !check(err) {\n+\t\tf.Close()\n+\t}\n+\tprt(n2, \"bytes written successfully\")\n+\terr = f.Close()\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\tf2, err := os.ReadFile(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\tprt(\"this is \", fn, \" file: \", string(f2))\n+}\n+\n+/*\n+4. create a decodehistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the calculator slice . At the start of this function clear out whatever was in the slice previously\n+json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n+*/\n+\n+func (c calculator) decodeHistory(fn string) (f []byte) {\n+\tf, err := os.ReadFile(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\t// var data []interface{}\n+\t// err = json.Unmarshal(f, &data)\n+\tmr := make([]mathRequest, 10)\n+\terr = json.Unmarshal(f, &mr)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\treturn f\n+}\n+\n+func (c calculator) addToHistory(fn string) {\n+\tmr := make([]mathRequest, 10)\n+\tf, err := os.ReadFile(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\terr = json.Unmarshal(f, &mr)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\n+\tc.history = nil\n+\tfor _, mRequest := range mr {\n+\t\tc.history = append(c.history, mathRequest(mRequest))\n+\t}\n+\tprt(\"this is the last history:\", c.printHistory())\n+}\n+\n+// ancillary function\n+func (c calculator) printHistory() (history []string) {\n+\tfor _, v := range c.history {\n+\t\thistory = append(history, fmt.Sprintf(\"%+v\", v))\n+\t}\n+\treturn history\n+}\n+\n+func main() {\n+\tprt(\"calculation with calculator:\")\n+\tprt(\"5 + 3 =\", calculator.add(5, 3))      // 8\n+\tprt(\"5 - 9 =\", calculator.sub(5, 9))      // -4\n+\tprt(\"22 * 33 =\", calculator.mult(22, 33)) // 726\n+\tprt(\"4 / 0 =\", calculator.divide(4, 0))   // impossible to divide by zero\n+\tprt(\"12 / 6 =\", calculator.divide(12, 6)) // 2\n+\tprt()\n+\t_ = calculator.encodeHistory()\n+\tcalculator.saveToFile(calculator.encodeHistory(), \"test.json\")\n+\t// opCalc.decodeHistory()\n+\thistory2 := []byte(`[{\"num1\":6,\"Operator\":\"add\",\"num2\":8},{\"num1\":2,\"Operator\":\"sub\",\"num2\":7},{\"num1\":8,\"Operator\":\"mult\",\"num2\":8},{\"num1\":33,\"Operator\":\"Div\",\"num2\":11}]`)\n+\tcalculator.saveToFile(history2, \"test2.json\")\n+\tcalculator.decodeHistory(\"test2.json\")\n+\tcalculator.addToHistory(\"test2.json\")\n+\tcalculator.printHistory()\n+}\n"
                },
                {
                    "date": 1689924912249,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -189,196 +189,4 @@\n \tcalculator.decodeHistory(\"test2.json\")\n \tcalculator.addToHistory(\"test2.json\")\n \tcalculator.printHistory()\n }\n-/*\n-Json allows us to serialize our data to use somewhere else\n-Serialization is also how we can 'save' our work to be used later - think saving in games and then reloading it so you dont have to start from the start\n-\n-In this exercise we will take CalculatorA from the last exercise with the add, mult, divide, and sub functions and add some new functionality to it\n-\n-You might have noticed that Calculators also have some semblance of history of the operations performed - so that is what we will add\n-\n-1. Create a mathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the Calculator. So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n-\n-2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n-\n-3. create an encodeHistory function this will loop over all the mathRequests in the history slice inside the CalculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax\n-\n-so something like this\n-\n-json.Marshal is how you convert a struct into a []byte - and then you can convert []byte into string\n-func (c Calculator) encodeHistory() []string {\n-    for _, mr := range c.history {\n-    }\n-}\n-4. create a decodeHistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the Calculator slice . At the start of this function clear out whatever was in the slice previously\n-\n-json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n-*/\n-\n-package main\n-\n-import (\n-\t\"encoding/json\"\n-\t\"fmt\"\n-\t\"os\"\n-)\n-\n-var prt = fmt.Println\n-\n-/*\n-1. Create a MathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the calculator.\n-So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n-*/\n-\n-type mathRequest struct {\n-\tnum1     int    `json:\"num1\"`\n-\toperator string `json:\"Operator\"`\n-\tnum2     int    `json:\"num2\"`\n-}\n-\n-/*\n-2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n-*/\n-\n-type calculator struct {\n-\thistory []mathRequest\n-}\n-\n-func (c calculator) add(num1 int, num2 int) int {\n-\top := mathRequest{num1, \"add\", num2}\n-\tc.history = append(c.history, op)\n-\treturn num1 + num2\n-}\n-\n-func (c calculator) sub(num1 int, num2 int) int {\n-\top := mathRequest{num1, \"sub\", num2}\n-\tc.history = append(c.history, op)\n-\treturn num1 - num2\n-}\n-\n-func (c calculator) mult(num1 int, num2 int) int {\n-\top := mathRequest{num1, \"mult\", num2}\n-\tc.history = append(c.history, op)\n-\treturn num1 * num2\n-}\n-\n-func (c calculator) divide(num1 int, num2 int) int {\n-\tif num2 == 0 {\n-\t\tprt(\"impossible to divide by zero\")\n-\t\treturn 0\n-\t}\n-\top := mathRequest{num1, \"Div\", num2}\n-\tc.history = append(c.history, op)\n-\treturn num1 / num2\n-}\n-\n-/*\n-3. create an encodehistory function this will loop over all the mathRequests in the history slice inside the calculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax. So something like this:\n-func (c calculator) encodehistory() []string {\n-    for _, mr := range c.history {\n-    }\n-}\n-*/\n-\n-func check(e error) (ok bool) {\n-\tif e != nil {\n-\t\tfmt.Printf(\"Error: %s\", e.Error())\n-\t\treturn false\n-\t}\n-\treturn true\n-}\n-\n-func (c calculator) encodeHistory() (eh []byte) {\n-\teh, err := json.Marshal(c.history)\n-\tif !check(err) {\n-\t\treturn nil\n-\t}\n-\t// prt(\"this is returned from json converter:\", string(j))\n-\treturn eh\n-}\n-\n-func (c calculator) saveToFile(eh []byte, fn string) {\n-\tf, err := os.Create(fn)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\tn2, err := f.Write(eh) // I should check if the file already exists but...\n-\tif !check(err) {\n-\t\tf.Close()\n-\t}\n-\tprt(n2, \"bytes written successfully\")\n-\terr = f.Close()\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\tf2, err := os.ReadFile(fn)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\tprt(\"this is \", fn, \" file: \", string(f2))\n-}\n-\n-/*\n-4. create a decodehistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the calculator slice . At the start of this function clear out whatever was in the slice previously\n-json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n-*/\n-\n-func (c calculator) decodeHistory(fn string) (f []byte) {\n-\tf, err := os.ReadFile(fn)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\t// var data []interface{}\n-\t// err = json.Unmarshal(f, &data)\n-\tmr := make([]mathRequest, 10)\n-\terr = json.Unmarshal(f, &mr)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\treturn f\n-}\n-\n-func (c calculator) addToHistory(fn string) {\n-\tmr := make([]mathRequest, 10)\n-\tf, err := os.ReadFile(fn)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\terr = json.Unmarshal(f, &mr)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\n-\tc.history = nil\n-\tfor _, mRequest := range mr {\n-\t\tc.history = append(c.history, mathRequest(mRequest))\n-\t}\n-\tprt(\"this is the last history:\", c.printHistory())\n-}\n-\n-// ancillary function\n-func (c calculator) printHistory() (history []string) {\n-\tfor _, v := range c.history {\n-\t\thistory = append(history, fmt.Sprintf(\"%+v\", v))\n-\t}\n-\treturn history\n-}\n-\n-func main() {\n-\tprt(\"calculation with calculator:\")\n-\tprt(\"5 + 3 =\", calculator.add(5, 3))      // 8\n-\tprt(\"5 - 9 =\", calculator.sub(5, 9))      // -4\n-\tprt(\"22 * 33 =\", calculator.mult(22, 33)) // 726\n-\tprt(\"4 / 0 =\", calculator.divide(4, 0))   // impossible to divide by zero\n-\tprt(\"12 / 6 =\", calculator.divide(12, 6)) // 2\n-\tprt()\n-\t_ = calc.encodeHistory()\n-\tcalc.saveToFile(calc.encodeHistory(), \"test.json\")\n-\t// opCalc.decodeHistory()\n-\thistory2 := []byte(`[{\"num1\":6,\"Operator\":\"add\",\"num2\":8},{\"num1\":2,\"Operator\":\"sub\",\"num2\":7},{\"num1\":8,\"Operator\":\"mult\",\"num2\":8},{\"num1\":33,\"Operator\":\"Div\",\"num2\":11}]`)\n-\tcalc.saveToFile(history2, \"test2.json\")\n-\tcalc.decodeHistory(\"test2.json\")\n-\tcalc.addToHistory(\"test2.json\")\n-\tcalc.printHistory()\n-}\n"
                },
                {
                    "date": 1689924930910,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -173,8 +173,9 @@\n \treturn history\n }\n \n func main() {\n+\t\n \tprt(\"calculation with calculator:\")\n \tprt(\"5 + 3 =\", calculator.add(5, 3))      // 8\n \tprt(\"5 - 9 =\", calculator.sub(5, 9))      // -4\n \tprt(\"22 * 33 =\", calculator.mult(22, 33)) // 726\n"
                },
                {
                    "date": 1689924937157,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -173,9 +173,9 @@\n \treturn history\n }\n \n func main() {\n-\t\n+\tcalculator := calculator\n \tprt(\"calculation with calculator:\")\n \tprt(\"5 + 3 =\", calculator.add(5, 3))      // 8\n \tprt(\"5 - 9 =\", calculator.sub(5, 9))      // -4\n \tprt(\"22 * 33 =\", calculator.mult(22, 33)) // 726\n"
                },
                {
                    "date": 1689925043658,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -158,11 +158,11 @@\n \t\treturn\n \t}\n \n \tc.history = nil\n-\tfor _, mRequest := range mr {\n-\t\tc.history = append(c.history, mathRequest(mRequest))\n-\t}\n+\t// for _, mRequest := range mr {\n+\t// \tc.history = append(c.history, mathRequest(mRequest))\n+\t// }\n \tprt(\"this is the last history:\", c.printHistory())\n }\n \n // ancillary function\n@@ -173,9 +173,9 @@\n \treturn history\n }\n \n func main() {\n-\tcalculator := calculator\n+\tcalculator := calculator{}\n \tprt(\"calculation with calculator:\")\n \tprt(\"5 + 3 =\", calculator.add(5, 3))      // 8\n \tprt(\"5 - 9 =\", calculator.sub(5, 9))      // -4\n \tprt(\"22 * 33 =\", calculator.mult(22, 33)) // 726\n"
                },
                {
                    "date": 1689925081884,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -161,8 +161,9 @@\n \tc.history = nil\n \t// for _, mRequest := range mr {\n \t// \tc.history = append(c.history, mathRequest(mRequest))\n \t// }\n+\t\n \tprt(\"this is the last history:\", c.printHistory())\n }\n \n // ancillary function\n"
                },
                {
                    "date": 1689925090530,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -161,9 +161,11 @@\n \tc.history = nil\n \t// for _, mRequest := range mr {\n \t// \tc.history = append(c.history, mathRequest(mRequest))\n \t// }\n-\t\n+\t// for _, mRequest := range mr {\n+\t// \tc.history = append(c.history, mathRequest(mRequest))\n+\t// }\n \tprt(\"this is the last history:\", c.printHistory())\n }\n \n // ancillary function\n"
                },
                {
                    "date": 1689925102665,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -161,11 +161,11 @@\n \tc.history = nil\n \t// for _, mRequest := range mr {\n \t// \tc.history = append(c.history, mathRequest(mRequest))\n \t// }\n-\t// for _, mRequest := range mr {\n-\t// \tc.history = append(c.history, mathRequest(mRequest))\n-\t// }\n+\tfor _, mRequest := range mr {\n+\t\tc.history = append(c.history, mRequest))\n+\t}\n \tprt(\"this is the last history:\", c.printHistory())\n }\n \n // ancillary function\n"
                },
                {
                    "date": 1689925121041,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -161,10 +161,10 @@\n \tc.history = nil\n \t// for _, mRequest := range mr {\n \t// \tc.history = append(c.history, mathRequest(mRequest))\n \t// }\n-\tfor _, mRequest := range mr {\n-\t\tc.history = append(c.history, mRequest))\n+\tfor _, c.history := range mr {\n+\t\tc.history = append(c.history, mRequest)\n \t}\n \tprt(\"this is the last history:\", c.printHistory())\n }\n \n"
                },
                {
                    "date": 1689925130731,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -161,9 +161,9 @@\n \tc.history = nil\n \t// for _, mRequest := range mr {\n \t// \tc.history = append(c.history, mathRequest(mRequest))\n \t// }\n-\tfor _, c.history := range mr {\n+\tfor _, mRequest := range mr {\n \t\tc.history = append(c.history, mRequest)\n \t}\n \tprt(\"this is the last history:\", c.printHistory())\n }\n"
                },
                {
                    "date": 1689925247675,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -186,9 +186,8 @@\n \tprt(\"12 / 6 =\", calculator.divide(12, 6)) // 2\n \tprt()\n \t_ = calculator.encodeHistory()\n \tcalculator.saveToFile(calculator.encodeHistory(), \"test.json\")\n-\t// opCalc.decodeHistory()\n \thistory2 := []byte(`[{\"num1\":6,\"Operator\":\"add\",\"num2\":8},{\"num1\":2,\"Operator\":\"sub\",\"num2\":7},{\"num1\":8,\"Operator\":\"mult\",\"num2\":8},{\"num1\":33,\"Operator\":\"Div\",\"num2\":11}]`)\n \tcalculator.saveToFile(history2, \"test2.json\")\n \tcalculator.decodeHistory(\"test2.json\")\n \tcalculator.addToHistory(\"test2.json\")\n"
                },
                {
                    "date": 1689925339356,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -162,9 +162,9 @@\n \t// for _, mRequest := range mr {\n \t// \tc.history = append(c.history, mathRequest(mRequest))\n \t// }\n \tfor _, mRequest := range mr {\n-\t\tc.history = append(c.history, mRequest)\n+\t\tc.history = append(c.history, mathRequest(mRequest))\n \t}\n \tprt(\"this is the last history:\", c.printHistory())\n }\n \n"
                },
                {
                    "date": 1689925413795,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,194 @@\n+/*\n+Json allows us to serialize our data to use somewhere else\n+Serialization is also how we can 'save' our work to be used later - think saving in games and then reloading it so you dont have to start from the start\n+\n+In this exercise we will take CalculatorA from the last exercise with the add, mult, divide, and sub functions and add some new functionality to it\n+\n+You might have noticed that Calculators also have some semblance of history of the operations performed - so that is what we will add\n+\n+1. Create a mathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the Calculator. So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n+\n+2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n+\n+3. create an encodeHistory function this will loop over all the mathRequests in the history slice inside the CalculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax\n+\n+so something like this\n+\n+json.Marshal is how you convert a struct into a []byte - and then you can convert []byte into string\n+func (c Calculator) encodeHistory() []string {\n+    for _, mr := range c.history {\n+    }\n+}\n+4. create a decodeHistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the Calculator slice . At the start of this function clear out whatever was in the slice previously\n+\n+json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n+*/\n+\n+package main\n+\n+import (\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"os\"\n+)\n+\n+var prt = fmt.Println\n+\n+/*\n+1. Create a MathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the calculator.\n+So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n+*/\n+\n+type mathRequest struct {\n+\tnum1     int    `json:\"num1\"`\n+\toperator string `json:\"Operator\"`\n+\tnum2     int    `json:\"num2\"`\n+}\n+\n+/*\n+2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n+*/\n+\n+type calculator struct {\n+\thistory []mathRequest\n+}\n+\n+func (c calculator) add(num1 int, num2 int) int {\n+\top := mathRequest{num1, \"add\", num2}\n+\tc.history = append(c.history, op)\n+\treturn num1 + num2\n+}\n+\n+func (c calculator) sub(num1 int, num2 int) int {\n+\top := mathRequest{num1, \"sub\", num2}\n+\tc.history = append(c.history, op)\n+\treturn num1 - num2\n+}\n+\n+func (c calculator) mult(num1 int, num2 int) int {\n+\top := mathRequest{num1, \"mult\", num2}\n+\tc.history = append(c.history, op)\n+\treturn num1 * num2\n+}\n+\n+func (c calculator) divide(num1 int, num2 int) int {\n+\tif num2 == 0 {\n+\t\tprt(\"impossible to divide by zero\")\n+\t\treturn 0\n+\t}\n+\top := mathRequest{num1, \"Div\", num2}\n+\tc.history = append(c.history, op)\n+\treturn num1 / num2\n+}\n+\n+/*\n+3. create an encodehistory function this will loop over all the mathRequests in the history slice inside the calculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax. So something like this:\n+func (c calculator) encodehistory() []string {\n+    for _, mr := range c.history {\n+    }\n+}\n+*/\n+\n+func check(e error) (ok bool) {\n+\tif e != nil {\n+\t\tfmt.Printf(\"Error: %s\", e.Error())\n+\t\treturn false\n+\t}\n+\treturn true\n+}\n+\n+func (c calculator) encodeHistory() (eh []byte) {\n+\teh, err := json.Marshal(c.history)\n+\tif !check(err) {\n+\t\treturn nil\n+\t}\n+\treturn eh\n+}\n+\n+func (c calculator) saveToFile(eh []byte, fn string) {\n+\tf, err := os.Create(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\tn2, err := f.Write(eh) // I should check if the file already exists but...\n+\tif !check(err) {\n+\t\tf.Close()\n+\t}\n+\tprt(n2, \"bytes written successfully\")\n+\terr = f.Close()\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\tf2, err := os.ReadFile(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\tprt(\"this is \", fn, \" file: \", string(f2))\n+}\n+\n+/*\n+4. create a decodehistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the calculator slice . At the start of this function clear out whatever was in the slice previously\n+json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n+*/\n+\n+func (c calculator) decodeHistory(fn string) (f []byte) {\n+\tf, err := os.ReadFile(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\t// var data []interface{}\n+\t// err = json.Unmarshal(f, &data)\n+\tmr := make([]mathRequest, 10)\n+\terr = json.Unmarshal(f, &mr)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\treturn f\n+}\n+\n+func (c calculator) addToHistory(fn string) {\n+\tmr := make([]mathRequest, 10)\n+\tf, err := os.ReadFile(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\terr = json.Unmarshal(f, &mr)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\n+\tc.history = nil\n+\t// for _, mRequest := range mr {\n+\t// \tc.history = append(c.history, mathRequest(mRequest))\n+\t// }\n+\tfor _, mRequest := range mr {\n+\t\tc.history = append(c.history, mathRequest(mRequest))\n+\t}\n+\tprt(\"this is the last history:\", c.printHistory())\n+}\n+\n+// ancillary function\n+func (c calculator) printHistory() (history []string) {\n+\tfor _, v := range c.history {\n+\t\thistory = append(history, fmt.Sprintf(\"%+v\", v))\n+\t}\n+\treturn history\n+}\n+\n+func main() {\n+\tcalculator := calculator{}\n+\tprt(\"calculation with calculator:\")\n+\tprt(\"5 + 3 =\", calculator.add(5, 3))      // 8\n+\tprt(\"5 - 9 =\", calculator.sub(5, 9))      // -4\n+\tprt(\"22 * 33 =\", calculator.mult(22, 33)) // 726\n+\tprt(\"4 / 0 =\", calculator.divide(4, 0))   // impossible to divide by zero\n+\tprt(\"12 / 6 =\", calculator.divide(12, 6)) // 2\n+\tprt()\n+\t_ = calculator.encodeHistory()\n+\tcalculator.saveToFile(calculator.encodeHistory(), \"test.json\")\n+\thistory2 := []byte(`[{\"num1\":6,\"Operator\":\"add\",\"num2\":8},{\"num1\":2,\"Operator\":\"sub\",\"num2\":7},{\"num1\":8,\"Operator\":\"mult\",\"num2\":8},{\"num1\":33,\"Operator\":\"Div\",\"num2\":11}]`)\n+\tcalculator.saveToFile(history2, \"test2.json\")\n+\tcalculator.decodeHistory(\"test2.json\")\n+\tcalculator.addToHistory(\"test2.json\")\n+\tcalculator.printHistory()\n+}\n"
                },
                {
                    "date": 1689925589522,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -97,8 +97,9 @@\n \treturn true\n }\n \n func (c calculator) encodeHistory() (eh []byte) {\n+\t\n \teh, err := json.Marshal(c.history)\n \tif !check(err) {\n \t\treturn nil\n \t}\n@@ -191,199 +192,4 @@\n \tcalculator.decodeHistory(\"test2.json\")\n \tcalculator.addToHistory(\"test2.json\")\n \tcalculator.printHistory()\n }\n-/*\n-Json allows us to serialize our data to use somewhere else\n-Serialization is also how we can 'save' our work to be used later - think saving in games and then reloading it so you dont have to start from the start\n-\n-In this exercise we will take CalculatorA from the last exercise with the add, mult, divide, and sub functions and add some new functionality to it\n-\n-You might have noticed that Calculators also have some semblance of history of the operations performed - so that is what we will add\n-\n-1. Create a mathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the Calculator. So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n-\n-2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n-\n-3. create an encodeHistory function this will loop over all the mathRequests in the history slice inside the CalculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax\n-\n-so something like this\n-\n-json.Marshal is how you convert a struct into a []byte - and then you can convert []byte into string\n-func (c Calculator) encodeHistory() []string {\n-    for _, mr := range c.history {\n-    }\n-}\n-4. create a decodeHistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the Calculator slice . At the start of this function clear out whatever was in the slice previously\n-\n-json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n-*/\n-\n-package main\n-\n-import (\n-\t\"encoding/json\"\n-\t\"fmt\"\n-\t\"os\"\n-)\n-\n-var prt = fmt.Println\n-\n-/*\n-1. Create a MathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the calculator.\n-So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n-*/\n-\n-type mathRequest struct {\n-\tnum1     int    `json:\"num1\"`\n-\toperator string `json:\"Operator\"`\n-\tnum2     int    `json:\"num2\"`\n-}\n-\n-/*\n-2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n-*/\n-\n-type calculator struct {\n-\thistory []mathRequest\n-}\n-\n-func (c calculator) add(num1 int, num2 int) int {\n-\top := mathRequest{num1, \"add\", num2}\n-\tc.history = append(c.history, op)\n-\treturn num1 + num2\n-}\n-\n-func (c calculator) sub(num1 int, num2 int) int {\n-\top := mathRequest{num1, \"sub\", num2}\n-\tc.history = append(c.history, op)\n-\treturn num1 - num2\n-}\n-\n-func (c calculator) mult(num1 int, num2 int) int {\n-\top := mathRequest{num1, \"mult\", num2}\n-\tc.history = append(c.history, op)\n-\treturn num1 * num2\n-}\n-\n-func (c calculator) divide(num1 int, num2 int) int {\n-\tif num2 == 0 {\n-\t\tprt(\"impossible to divide by zero\")\n-\t\treturn 0\n-\t}\n-\top := mathRequest{num1, \"Div\", num2}\n-\tc.history = append(c.history, op)\n-\treturn num1 / num2\n-}\n-\n-/*\n-3. create an encodehistory function this will loop over all the mathRequests in the history slice inside the calculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax. So something like this:\n-func (c calculator) encodehistory() []string {\n-    for _, mr := range c.history {\n-    }\n-}\n-*/\n-\n-func check(e error) (ok bool) {\n-\tif e != nil {\n-\t\tfmt.Printf(\"Error: %s\", e.Error())\n-\t\treturn false\n-\t}\n-\treturn true\n-}\n-\n-func (c calculator) encodeHistory() (eh []byte) {\n-\teh, err := json.Marshal(c.history)\n-\tif !check(err) {\n-\t\treturn nil\n-\t}\n-\t// prt(\"this is returned from json converter:\", string(j))\n-\treturn eh\n-}\n-\n-func (c calculator) saveToFile(eh []byte, fn string) {\n-\tf, err := os.Create(fn)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\tn2, err := f.Write(eh) // I should check if the file already exists but...\n-\tif !check(err) {\n-\t\tf.Close()\n-\t}\n-\tprt(n2, \"bytes written successfully\")\n-\terr = f.Close()\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\tf2, err := os.ReadFile(fn)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\tprt(\"this is \", fn, \" file: \", string(f2))\n-}\n-\n-/*\n-4. create a decodehistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the calculator slice . At the start of this function clear out whatever was in the slice previously\n-json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n-*/\n-\n-func (c calculator) decodeHistory(fn string) (f []byte) {\n-\tf, err := os.ReadFile(fn)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\t// var data []interface{}\n-\t// err = json.Unmarshal(f, &data)\n-\tmr := make([]mathRequest, 10)\n-\terr = json.Unmarshal(f, &mr)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\treturn f\n-}\n-\n-func (c calculator) addToHistory(fn string) {\n-\tmr := make([]mathRequest, 10)\n-\tf, err := os.ReadFile(fn)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\terr = json.Unmarshal(f, &mr)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\n-\tc.history = nil\n-\t// for _, mRequest := range mr {\n-\t// \tc.history = append(c.history, mathRequest(mRequest))\n-\t// }\n-\tfor _, mRequest := range mr {\n-\t\tc.history = append(c.history, mathRequest(mRequest))\n-\t}\n-\tprt(\"this is the last history:\", c.printHistory())\n-}\n-\n-// ancillary function\n-func (c calculator) printHistory() (history []string) {\n-\tfor _, v := range c.history {\n-\t\thistory = append(history, fmt.Sprintf(\"%+v\", v))\n-\t}\n-\treturn history\n-}\n-\n-func main() {\n-\tcalculator := calculator{}\n-\tprt(\"calculation with calculator:\")\n-\tprt(\"5 + 3 =\", calculator.add(5, 3))      // 8\n-\tprt(\"5 - 9 =\", calculator.sub(5, 9))      // -4\n-\tprt(\"22 * 33 =\", calculator.mult(22, 33)) // 726\n-\tprt(\"4 / 0 =\", calculator.divide(4, 0))   // impossible to divide by zero\n-\tprt(\"12 / 6 =\", calculator.divide(12, 6)) // 2\n-\tprt()\n-\t_ = calculator.encodeHistory()\n-\tcalculator.saveToFile(calculator.encodeHistory(), \"test.json\")\n-\thistory2 := []byte(`[{\"num1\":6,\"Operator\":\"add\",\"num2\":8},{\"num1\":2,\"Operator\":\"sub\",\"num2\":7},{\"num1\":8,\"Operator\":\"mult\",\"num2\":8},{\"num1\":33,\"Operator\":\"Div\",\"num2\":11}]`)\n-\tcalculator.saveToFile(history2, \"test2.json\")\n-\tcalculator.decodeHistory(\"test2.json\")\n-\tcalculator.addToHistory(\"test2.json\")\n-\tcalculator.printHistory()\n-}\n"
                },
                {
                    "date": 1689925595281,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -97,9 +97,9 @@\n \treturn true\n }\n \n func (c calculator) encodeHistory() (eh []byte) {\n-\t\n+\tprt(c.history)\n \teh, err := json.Marshal(c.history)\n \tif !check(err) {\n \t\treturn nil\n \t}\n"
                },
                {
                    "date": 1689925638399,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -54,9 +54,9 @@\n }\n \n func (c calculator) add(num1 int, num2 int) int {\n \top := mathRequest{num1, \"add\", num2}\n-\tc.history = append(c.history, op)\n+\tc.history = append(c.history, mathRequest{num1, \"add\", num2})\n \treturn num1 + num2\n }\n \n func (c calculator) sub(num1 int, num2 int) int {\n"
                },
                {
                    "date": 1689925646209,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,9 +53,9 @@\n \thistory []mathRequest\n }\n \n func (c calculator) add(num1 int, num2 int) int {\n-\top := mathRequest{num1, \"add\", num2}\n+\t// op := mathRequest{num1, \"add\", num2}\n \tc.history = append(c.history, mathRequest{num1, \"add\", num2})\n \treturn num1 + num2\n }\n \n"
                },
                {
                    "date": 1689925653734,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -60,9 +60,9 @@\n }\n \n func (c calculator) sub(num1 int, num2 int) int {\n \top := mathRequest{num1, \"sub\", num2}\n-\tc.history = append(c.history, op)\n+\tc.history = append(c.history, mathRequest{num1, \"sub\", num2})\n \treturn num1 - num2\n }\n \n func (c calculator) mult(num1 int, num2 int) int {\n"
                },
                {
                    "date": 1689925660494,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -59,9 +59,9 @@\n \treturn num1 + num2\n }\n \n func (c calculator) sub(num1 int, num2 int) int {\n-\top := mathRequest{num1, \"sub\", num2}\n+\t// op := mathRequest{num1, \"sub\", num2}\n \tc.history = append(c.history, mathRequest{num1, \"sub\", num2})\n \treturn num1 - num2\n }\n \n"
                },
                {
                    "date": 1689925666646,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -66,9 +66,9 @@\n }\n \n func (c calculator) mult(num1 int, num2 int) int {\n \top := mathRequest{num1, \"mult\", num2}\n-\tc.history = append(c.history, op)\n+\tc.history = append(c.history, mathRequest{num1, \"mult\", num2})\n \treturn num1 * num2\n }\n \n func (c calculator) divide(num1 int, num2 int) int {\n"
                },
                {
                    "date": 1689925676677,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -65,9 +65,9 @@\n \treturn num1 - num2\n }\n \n func (c calculator) mult(num1 int, num2 int) int {\n-\top := mathRequest{num1, \"mult\", num2}\n+\t// op := mathRequest{num1, \"mult\", num2}\n \tc.history = append(c.history, mathRequest{num1, \"mult\", num2})\n \treturn num1 * num2\n }\n \n@@ -76,9 +76,9 @@\n \t\tprt(\"impossible to divide by zero\")\n \t\treturn 0\n \t}\n \top := mathRequest{num1, \"Div\", num2}\n-\tc.history = append(c.history, op)\n+\tc.history = append(c.history, mathRequest{num1, \"Div\", num2})\n \treturn num1 / num2\n }\n \n /*\n"
                },
                {
                    "date": 1689925702281,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,22 +53,22 @@\n \thistory []mathRequest\n }\n \n func (c calculator) add(num1 int, num2 int) int {\n-\t// op := mathRequest{num1, \"add\", num2}\n-\tc.history = append(c.history, mathRequest{num1, \"add\", num2})\n+\top := mathRequest{num1, \"add\", num2}\n+\tc.history = append(c.history, op)\n \treturn num1 + num2\n }\n \n func (c calculator) sub(num1 int, num2 int) int {\n-\t// op := mathRequest{num1, \"sub\", num2}\n-\tc.history = append(c.history, mathRequest{num1, \"sub\", num2})\n+\top := mathRequest{num1, \"sub\", num2}\n+\tc.history = append(c.history, op)\n \treturn num1 - num2\n }\n \n func (c calculator) mult(num1 int, num2 int) int {\n-\t// op := mathRequest{num1, \"mult\", num2}\n-\tc.history = append(c.history, mathRequest{num1, \"mult\", num2})\n+\top := mathRequest{num1, \"mult\", num2}\n+\tc.history = append(c.history, op)\n \treturn num1 * num2\n }\n \n func (c calculator) divide(num1 int, num2 int) int {\n@@ -76,9 +76,9 @@\n \t\tprt(\"impossible to divide by zero\")\n \t\treturn 0\n \t}\n \top := mathRequest{num1, \"Div\", num2}\n-\tc.history = append(c.history, mathRequest{num1, \"Div\", num2})\n+\tc.history = append(c.history, op)\n \treturn num1 / num2\n }\n \n /*\n"
                },
                {
                    "date": 1689925852820,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -39,9 +39,9 @@\n So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n */\n \n type mathRequest struct {\n-\tnum1     int    `json:\"num1\"`\n+\tNum1     int    `json:\"num1\"`\n \toperator string `json:\"Operator\"`\n \tnum2     int    `json:\"num2\"`\n }\n \n"
                },
                {
                    "date": 1689925858595,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -40,10 +40,10 @@\n */\n \n type mathRequest struct {\n \tNum1     int    `json:\"num1\"`\n-\toperator string `json:\"Operator\"`\n-\tnum2     int    `json:\"num2\"`\n+\tOperator string `json:\"Operator\"`\n+\tNum2     int    `json:\"num2\"`\n }\n \n /*\n 2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n"
                },
                {
                    "date": 1689925868182,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,195 @@\n+/*\n+Json allows us to serialize our data to use somewhere else\n+Serialization is also how we can 'save' our work to be used later - think saving in games and then reloading it so you dont have to start from the start\n+\n+In this exercise we will take CalculatorA from the last exercise with the add, mult, divide, and sub functions and add some new functionality to it\n+\n+You might have noticed that Calculators also have some semblance of history of the operations performed - so that is what we will add\n+\n+1. Create a mathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the Calculator. So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n+\n+2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n+\n+3. create an encodeHistory function this will loop over all the mathRequests in the history slice inside the CalculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax\n+\n+so something like this\n+\n+json.Marshal is how you convert a struct into a []byte - and then you can convert []byte into string\n+func (c Calculator) encodeHistory() []string {\n+    for _, mr := range c.history {\n+    }\n+}\n+4. create a decodeHistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the Calculator slice . At the start of this function clear out whatever was in the slice previously\n+\n+json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n+*/\n+\n+package main\n+\n+import (\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"os\"\n+)\n+\n+var prt = fmt.Println\n+\n+/*\n+1. Create a MathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the calculator.\n+So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n+*/\n+\n+type mathRequest struct {\n+\tNum1     int    `json:\"num1\"`\n+\tOperator string `json:\"Operator\"`\n+\tNum2     int    `json:\"num2\"`\n+}\n+\n+/*\n+2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n+*/\n+\n+type calculator struct {\n+\thistory []mathRequest\n+}\n+\n+func (c calculator) add(num1 int, num2 int) int {\n+\top := mathRequest{num1, \"add\", num2}\n+\tc.history = append(c.history, op)\n+\treturn num1 + num2\n+}\n+\n+func (c calculator) sub(num1 int, num2 int) int {\n+\top := mathRequest{num1, \"sub\", num2}\n+\tc.history = append(c.history, op)\n+\treturn num1 - num2\n+}\n+\n+func (c calculator) mult(num1 int, num2 int) int {\n+\top := mathRequest{num1, \"mult\", num2}\n+\tc.history = append(c.history, op)\n+\treturn num1 * num2\n+}\n+\n+func (c calculator) divide(num1 int, num2 int) int {\n+\tif num2 == 0 {\n+\t\tprt(\"impossible to divide by zero\")\n+\t\treturn 0\n+\t}\n+\top := mathRequest{num1, \"Div\", num2}\n+\tc.history = append(c.history, op)\n+\treturn num1 / num2\n+}\n+\n+/*\n+3. create an encodehistory function this will loop over all the mathRequests in the history slice inside the calculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax. So something like this:\n+func (c calculator) encodehistory() []string {\n+    for _, mr := range c.history {\n+    }\n+}\n+*/\n+\n+func check(e error) (ok bool) {\n+\tif e != nil {\n+\t\tfmt.Printf(\"Error: %s\", e.Error())\n+\t\treturn false\n+\t}\n+\treturn true\n+}\n+\n+func (c calculator) encodeHistory() (eh []byte) {\n+\tprt(c.history)\n+\teh, err := json.Marshal(c.history)\n+\tif !check(err) {\n+\t\treturn nil\n+\t}\n+\treturn eh\n+}\n+\n+func (c calculator) saveToFile(eh []byte, fn string) {\n+\tf, err := os.Create(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\tn2, err := f.Write(eh) // I should check if the file already exists but...\n+\tif !check(err) {\n+\t\tf.Close()\n+\t}\n+\tprt(n2, \"bytes written successfully\")\n+\terr = f.Close()\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\tf2, err := os.ReadFile(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\tprt(\"this is \", fn, \" file: \", string(f2))\n+}\n+\n+/*\n+4. create a decodehistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the calculator slice . At the start of this function clear out whatever was in the slice previously\n+json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n+*/\n+\n+func (c calculator) decodeHistory(fn string) (f []byte) {\n+\tf, err := os.ReadFile(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\t// var data []interface{}\n+\t// err = json.Unmarshal(f, &data)\n+\tmr := make([]mathRequest, 10)\n+\terr = json.Unmarshal(f, &mr)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\treturn f\n+}\n+\n+func (c calculator) addToHistory(fn string) {\n+\tmr := make([]mathRequest, 10)\n+\tf, err := os.ReadFile(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\terr = json.Unmarshal(f, &mr)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\n+\tc.history = nil\n+\t// for _, mRequest := range mr {\n+\t// \tc.history = append(c.history, mathRequest(mRequest))\n+\t// }\n+\tfor _, mRequest := range mr {\n+\t\tc.history = append(c.history, mathRequest(mRequest))\n+\t}\n+\tprt(\"this is the last history:\", c.printHistory())\n+}\n+\n+// ancillary function\n+func (c calculator) printHistory() (history []string) {\n+\tfor _, v := range c.history {\n+\t\thistory = append(history, fmt.Sprintf(\"%+v\", v))\n+\t}\n+\treturn history\n+}\n+\n+func main() {\n+\tcalculator := calculator{}\n+\tprt(\"calculation with calculator:\")\n+\tprt(\"5 + 3 =\", calculator.add(5, 3))      // 8\n+\tprt(\"5 - 9 =\", calculator.sub(5, 9))      // -4\n+\tprt(\"22 * 33 =\", calculator.mult(22, 33)) // 726\n+\tprt(\"4 / 0 =\", calculator.divide(4, 0))   // impossible to divide by zero\n+\tprt(\"12 / 6 =\", calculator.divide(12, 6)) // 2\n+\tprt()\n+\t_ = calculator.encodeHistory()\n+\tcalculator.saveToFile(calculator.encodeHistory(), \"test.json\")\n+\thistory2 := []byte(`[{\"Num1\":6,\"Operator\":\"add\",\"num2\":8},{\"num1\":2,\"Operator\":\"sub\",\"num2\":7},{\"num1\":8,\"Operator\":\"mult\",\"num2\":8},{\"num1\":33,\"Operator\":\"Div\",\"num2\":11}]`)\n+\tcalculator.saveToFile(history2, \"test2.json\")\n+\tcalculator.decodeHistory(\"test2.json\")\n+\tcalculator.addToHistory(\"test2.json\")\n+\tcalculator.printHistory()\n+}\n"
                },
                {
                    "date": 1689925873699,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -186,205 +186,10 @@\n \tprt(\"12 / 6 =\", calculator.divide(12, 6)) // 2\n \tprt()\n \t_ = calculator.encodeHistory()\n \tcalculator.saveToFile(calculator.encodeHistory(), \"test.json\")\n-\thistory2 := []byte(`[{\"Num1\":6,\"Operator\":\"add\",\"num2\":8},{\"num1\":2,\"Operator\":\"sub\",\"num2\":7},{\"num1\":8,\"Operator\":\"mult\",\"num2\":8},{\"num1\":33,\"Operator\":\"Div\",\"num2\":11}]`)\n+\thistory2 := []byte(`[{\"Num1\":6,\"Operator\":\"add\",\"Num2\":8},{\"num1\":2,\"Operator\":\"sub\",\"num2\":7},{\"num1\":8,\"Operator\":\"mult\",\"num2\":8},{\"num1\":33,\"Operator\":\"Div\",\"num2\":11}]`)\n \tcalculator.saveToFile(history2, \"test2.json\")\n \tcalculator.decodeHistory(\"test2.json\")\n \tcalculator.addToHistory(\"test2.json\")\n \tcalculator.printHistory()\n }\n-/*\n-Json allows us to serialize our data to use somewhere else\n-Serialization is also how we can 'save' our work to be used later - think saving in games and then reloading it so you dont have to start from the start\n-\n-In this exercise we will take CalculatorA from the last exercise with the add, mult, divide, and sub functions and add some new functionality to it\n-\n-You might have noticed that Calculators also have some semblance of history of the operations performed - so that is what we will add\n-\n-1. Create a mathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the Calculator. So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n-\n-2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n-\n-3. create an encodeHistory function this will loop over all the mathRequests in the history slice inside the CalculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax\n-\n-so something like this\n-\n-json.Marshal is how you convert a struct into a []byte - and then you can convert []byte into string\n-func (c Calculator) encodeHistory() []string {\n-    for _, mr := range c.history {\n-    }\n-}\n-4. create a decodeHistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the Calculator slice . At the start of this function clear out whatever was in the slice previously\n-\n-json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n-*/\n-\n-package main\n-\n-import (\n-\t\"encoding/json\"\n-\t\"fmt\"\n-\t\"os\"\n-)\n-\n-var prt = fmt.Println\n-\n-/*\n-1. Create a MathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the calculator.\n-So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n-*/\n-\n-type mathRequest struct {\n-\tNum1     int    `json:\"num1\"`\n-\tOperator string `json:\"Operator\"`\n-\tNum2     int    `json:\"num2\"`\n-}\n-\n-/*\n-2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n-*/\n-\n-type calculator struct {\n-\thistory []mathRequest\n-}\n-\n-func (c calculator) add(num1 int, num2 int) int {\n-\top := mathRequest{num1, \"add\", num2}\n-\tc.history = append(c.history, op)\n-\treturn num1 + num2\n-}\n-\n-func (c calculator) sub(num1 int, num2 int) int {\n-\top := mathRequest{num1, \"sub\", num2}\n-\tc.history = append(c.history, op)\n-\treturn num1 - num2\n-}\n-\n-func (c calculator) mult(num1 int, num2 int) int {\n-\top := mathRequest{num1, \"mult\", num2}\n-\tc.history = append(c.history, op)\n-\treturn num1 * num2\n-}\n-\n-func (c calculator) divide(num1 int, num2 int) int {\n-\tif num2 == 0 {\n-\t\tprt(\"impossible to divide by zero\")\n-\t\treturn 0\n-\t}\n-\top := mathRequest{num1, \"Div\", num2}\n-\tc.history = append(c.history, op)\n-\treturn num1 / num2\n-}\n-\n-/*\n-3. create an encodehistory function this will loop over all the mathRequests in the history slice inside the calculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax. So something like this:\n-func (c calculator) encodehistory() []string {\n-    for _, mr := range c.history {\n-    }\n-}\n-*/\n-\n-func check(e error) (ok bool) {\n-\tif e != nil {\n-\t\tfmt.Printf(\"Error: %s\", e.Error())\n-\t\treturn false\n-\t}\n-\treturn true\n-}\n-\n-func (c calculator) encodeHistory() (eh []byte) {\n-\tprt(c.history)\n-\teh, err := json.Marshal(c.history)\n-\tif !check(err) {\n-\t\treturn nil\n-\t}\n-\treturn eh\n-}\n-\n-func (c calculator) saveToFile(eh []byte, fn string) {\n-\tf, err := os.Create(fn)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\tn2, err := f.Write(eh) // I should check if the file already exists but...\n-\tif !check(err) {\n-\t\tf.Close()\n-\t}\n-\tprt(n2, \"bytes written successfully\")\n-\terr = f.Close()\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\tf2, err := os.ReadFile(fn)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\tprt(\"this is \", fn, \" file: \", string(f2))\n-}\n-\n-/*\n-4. create a decodehistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the calculator slice . At the start of this function clear out whatever was in the slice previously\n-json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n-*/\n-\n-func (c calculator) decodeHistory(fn string) (f []byte) {\n-\tf, err := os.ReadFile(fn)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\t// var data []interface{}\n-\t// err = json.Unmarshal(f, &data)\n-\tmr := make([]mathRequest, 10)\n-\terr = json.Unmarshal(f, &mr)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\treturn f\n-}\n-\n-func (c calculator) addToHistory(fn string) {\n-\tmr := make([]mathRequest, 10)\n-\tf, err := os.ReadFile(fn)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\terr = json.Unmarshal(f, &mr)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\n-\tc.history = nil\n-\t// for _, mRequest := range mr {\n-\t// \tc.history = append(c.history, mathRequest(mRequest))\n-\t// }\n-\tfor _, mRequest := range mr {\n-\t\tc.history = append(c.history, mathRequest(mRequest))\n-\t}\n-\tprt(\"this is the last history:\", c.printHistory())\n-}\n-\n-// ancillary function\n-func (c calculator) printHistory() (history []string) {\n-\tfor _, v := range c.history {\n-\t\thistory = append(history, fmt.Sprintf(\"%+v\", v))\n-\t}\n-\treturn history\n-}\n-\n-func main() {\n-\tcalculator := calculator{}\n-\tprt(\"calculation with calculator:\")\n-\tprt(\"5 + 3 =\", calculator.add(5, 3))      // 8\n-\tprt(\"5 - 9 =\", calculator.sub(5, 9))      // -4\n-\tprt(\"22 * 33 =\", calculator.mult(22, 33)) // 726\n-\tprt(\"4 / 0 =\", calculator.divide(4, 0))   // impossible to divide by zero\n-\tprt(\"12 / 6 =\", calculator.divide(12, 6)) // 2\n-\tprt()\n-\t_ = calculator.encodeHistory()\n-\tcalculator.saveToFile(calculator.encodeHistory(), \"test.json\")\n-\thistory2 := []byte(`[{\"num1\":6,\"Operator\":\"add\",\"num2\":8},{\"num1\":2,\"Operator\":\"sub\",\"num2\":7},{\"num1\":8,\"Operator\":\"mult\",\"num2\":8},{\"num1\":33,\"Operator\":\"Div\",\"num2\":11}]`)\n-\tcalculator.saveToFile(history2, \"test2.json\")\n-\tcalculator.decodeHistory(\"test2.json\")\n-\tcalculator.addToHistory(\"test2.json\")\n-\tcalculator.printHistory()\n-}\n"
                },
                {
                    "date": 1689925880425,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -186,9 +186,9 @@\n \tprt(\"12 / 6 =\", calculator.divide(12, 6)) // 2\n \tprt()\n \t_ = calculator.encodeHistory()\n \tcalculator.saveToFile(calculator.encodeHistory(), \"test.json\")\n-\thistory2 := []byte(`[{\"Num1\":6,\"Operator\":\"add\",\"Num2\":8},{\"num1\":2,\"Operator\":\"sub\",\"num2\":7},{\"num1\":8,\"Operator\":\"mult\",\"num2\":8},{\"num1\":33,\"Operator\":\"Div\",\"num2\":11}]`)\n+\thistory2 := []byte(`[{\"Num1\":6,\"Operator\":\"add\",\"Num2\":8},{\"Num1\":2,\"Operator\":\"sub\",\"Num2\":7},{\"Num1\":8,\"Operator\":\"mult\",\"num2\":8},{\"num1\":33,\"Operator\":\"Div\",\"num2\":11}]`)\n \tcalculator.saveToFile(history2, \"test2.json\")\n \tcalculator.decodeHistory(\"test2.json\")\n \tcalculator.addToHistory(\"test2.json\")\n \tcalculator.printHistory()\n"
                },
                {
                    "date": 1689925886590,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -186,9 +186,9 @@\n \tprt(\"12 / 6 =\", calculator.divide(12, 6)) // 2\n \tprt()\n \t_ = calculator.encodeHistory()\n \tcalculator.saveToFile(calculator.encodeHistory(), \"test.json\")\n-\thistory2 := []byte(`[{\"Num1\":6,\"Operator\":\"add\",\"Num2\":8},{\"Num1\":2,\"Operator\":\"sub\",\"Num2\":7},{\"Num1\":8,\"Operator\":\"mult\",\"num2\":8},{\"num1\":33,\"Operator\":\"Div\",\"num2\":11}]`)\n+\thistory2 := []byte(`[{\"Num1\":6,\"Operator\":\"add\",\"Num2\":8},{\"Num1\":2,\"Operator\":\"sub\",\"Num2\":7},{\"Num1\":8,\"Operator\":\"mult\",\"Num2\":8},{\"Num1\":33,\"Operator\":\"Div\",\"num2\":11}]`)\n \tcalculator.saveToFile(history2, \"test2.json\")\n \tcalculator.decodeHistory(\"test2.json\")\n \tcalculator.addToHistory(\"test2.json\")\n \tcalculator.printHistory()\n"
                },
                {
                    "date": 1689925897772,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -186,9 +186,9 @@\n \tprt(\"12 / 6 =\", calculator.divide(12, 6)) // 2\n \tprt()\n \t_ = calculator.encodeHistory()\n \tcalculator.saveToFile(calculator.encodeHistory(), \"test.json\")\n-\thistory2 := []byte(`[{\"Num1\":6,\"Operator\":\"add\",\"Num2\":8},{\"Num1\":2,\"Operator\":\"sub\",\"Num2\":7},{\"Num1\":8,\"Operator\":\"mult\",\"Num2\":8},{\"Num1\":33,\"Operator\":\"Div\",\"num2\":11}]`)\n+\thistory2 := []byte(`[{\"Num1\":6,\"Operator\":\"add\",\"Num2\":8},{\"Num1\":2,\"Operator\":\"sub\",\"Num2\":7},{\"Num1\":8,\"Operator\":\"mult\",\"Num2\":8},{\"Num1\":33,\"Operator\":\"Div\",\"Num2\":11}]`)\n \tcalculator.saveToFile(history2, \"test2.json\")\n \tcalculator.decodeHistory(\"test2.json\")\n \tcalculator.addToHistory(\"test2.json\")\n \tcalculator.printHistory()\n"
                },
                {
                    "date": 1689925940920,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,9 +49,9 @@\n 2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n */\n \n type calculator struct {\n-\thistory []mathRequest\n+\tHistory []mathRequest\n }\n \n func (c calculator) add(num1 int, num2 int) int {\n \top := mathRequest{num1, \"add\", num2}\n"
                },
                {
                    "date": 1689925948993,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -54,21 +54,21 @@\n }\n \n func (c calculator) add(num1 int, num2 int) int {\n \top := mathRequest{num1, \"add\", num2}\n-\tc.history = append(c.history, op)\n+\tc.History = append(c.History, op)\n \treturn num1 + num2\n }\n \n func (c calculator) sub(num1 int, num2 int) int {\n \top := mathRequest{num1, \"sub\", num2}\n-\tc.history = append(c.history, op)\n+\tc.History = append(c.History, op)\n \treturn num1 - num2\n }\n \n func (c calculator) mult(num1 int, num2 int) int {\n \top := mathRequest{num1, \"mult\", num2}\n-\tc.history = append(c.history, op)\n+\tc.History = append(c.History, op)\n \treturn num1 * num2\n }\n \n func (c calculator) divide(num1 int, num2 int) int {\n@@ -76,9 +76,9 @@\n \t\tprt(\"impossible to divide by zero\")\n \t\treturn 0\n \t}\n \top := mathRequest{num1, \"Div\", num2}\n-\tc.history = append(c.history, op)\n+\tc.History = append(c.History, op)\n \treturn num1 / num2\n }\n \n /*\n"
                },
                {
                    "date": 1689925956064,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -97,10 +97,10 @@\n \treturn true\n }\n \n func (c calculator) encodeHistory() (eh []byte) {\n-\tprt(c.history)\n-\teh, err := json.Marshal(c.history)\n+\tprt(c.History)\n+\teh, err := json.Marshal(c.History)\n \tif !check(err) {\n \t\treturn nil\n \t}\n \treturn eh\n"
                },
                {
                    "date": 1689925962735,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -157,9 +157,9 @@\n \tif !check(err) {\n \t\treturn\n \t}\n \n-\tc.history = nil\n+\tc.History = nil\n \t// for _, mRequest := range mr {\n \t// \tc.history = append(c.history, mathRequest(mRequest))\n \t// }\n \tfor _, mRequest := range mr {\n"
                },
                {
                    "date": 1689925983301,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,195 @@\n+/*\n+Json allows us to serialize our data to use somewhere else\n+Serialization is also how we can 'save' our work to be used later - think saving in games and then reloading it so you dont have to start from the start\n+\n+In this exercise we will take CalculatorA from the last exercise with the add, mult, divide, and sub functions and add some new functionality to it\n+\n+You might have noticed that Calculators also have some semblance of history of the operations performed - so that is what we will add\n+\n+1. Create a mathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the Calculator. So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n+\n+2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n+\n+3. create an encodeHistory function this will loop over all the mathRequests in the history slice inside the CalculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax\n+\n+so something like this\n+\n+json.Marshal is how you convert a struct into a []byte - and then you can convert []byte into string\n+func (c Calculator) encodeHistory() []string {\n+    for _, mr := range c.history {\n+    }\n+}\n+4. create a decodeHistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the Calculator slice . At the start of this function clear out whatever was in the slice previously\n+\n+json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n+*/\n+\n+package main\n+\n+import (\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"os\"\n+)\n+\n+var prt = fmt.Println\n+\n+/*\n+1. Create a MathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the calculator.\n+So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n+*/\n+\n+type mathRequest struct {\n+\tNum1     int    `json:\"num1\"`\n+\tOperator string `json:\"Operator\"`\n+\tNum2     int    `json:\"num2\"`\n+}\n+\n+/*\n+2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n+*/\n+\n+type calculator struct {\n+\tHistory []mathRequest\n+}\n+\n+func (c calculator) add(num1 int, num2 int) int {\n+\top := mathRequest{num1, \"add\", num2}\n+\tc.History = append(c.History, op)\n+\treturn num1 + num2\n+}\n+\n+func (c calculator) sub(num1 int, num2 int) int {\n+\top := mathRequest{num1, \"sub\", num2}\n+\tc.History = append(c.History, op)\n+\treturn num1 - num2\n+}\n+\n+func (c calculator) mult(num1 int, num2 int) int {\n+\top := mathRequest{num1, \"mult\", num2}\n+\tc.History = append(c.History, op)\n+\treturn num1 * num2\n+}\n+\n+func (c calculator) divide(num1 int, num2 int) int {\n+\tif num2 == 0 {\n+\t\tprt(\"impossible to divide by zero\")\n+\t\treturn 0\n+\t}\n+\top := mathRequest{num1, \"Div\", num2}\n+\tc.History = append(c.History, op)\n+\treturn num1 / num2\n+}\n+\n+/*\n+3. create an encodehistory function this will loop over all the mathRequests in the history slice inside the calculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax. So something like this:\n+func (c calculator) encodehistory() []string {\n+    for _, mr := range c.history {\n+    }\n+}\n+*/\n+\n+func check(e error) (ok bool) {\n+\tif e != nil {\n+\t\tfmt.Printf(\"Error: %s\", e.Error())\n+\t\treturn false\n+\t}\n+\treturn true\n+}\n+\n+func (c calculator) encodeHistory() (eh []byte) {\n+\tprt(c.History)\n+\teh, err := json.Marshal(c.History)\n+\tif !check(err) {\n+\t\treturn nil\n+\t}\n+\treturn eh\n+}\n+\n+func (c calculator) saveToFile(eh []byte, fn string) {\n+\tf, err := os.Create(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\tn2, err := f.Write(eh) // I should check if the file already exists but...\n+\tif !check(err) {\n+\t\tf.Close()\n+\t}\n+\tprt(n2, \"bytes written successfully\")\n+\terr = f.Close()\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\tf2, err := os.ReadFile(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\tprt(\"this is \", fn, \" file: \", string(f2))\n+}\n+\n+/*\n+4. create a decodehistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the calculator slice . At the start of this function clear out whatever was in the slice previously\n+json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n+*/\n+\n+func (c calculator) decodeHistory(fn string) (f []byte) {\n+\tf, err := os.ReadFile(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\t// var data []interface{}\n+\t// err = json.Unmarshal(f, &data)\n+\tmr := make([]mathRequest, 10)\n+\terr = json.Unmarshal(f, &mr)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\treturn f\n+}\n+\n+func (c calculator) addToHistory(fn string) {\n+\tmr := make([]mathRequest, 10)\n+\tf, err := os.ReadFile(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\terr = json.Unmarshal(f, &mr)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\n+\tc.History = nil\n+\t// for _, mRequest := range mr {\n+\t// \tc.history = append(c.history, mathRequest(mRequest))\n+\t// }\n+\tfor _, mRequest := range mr {\n+\t\tc.History = append(c.History, mathRequest(mRequest))\n+\t}\n+\tprt(\"this is the last history:\", c.printHistory())\n+}\n+\n+// ancillary function\n+func (c calculator) printHistory() (History []string) {\n+\tfor _, v := range c.history {\n+\t\thistory = append(history, fmt.Sprintf(\"%+v\", v))\n+\t}\n+\treturn history\n+}\n+\n+func main() {\n+\tcalculator := calculator{}\n+\tprt(\"calculation with calculator:\")\n+\tprt(\"5 + 3 =\", calculator.add(5, 3))      // 8\n+\tprt(\"5 - 9 =\", calculator.sub(5, 9))      // -4\n+\tprt(\"22 * 33 =\", calculator.mult(22, 33)) // 726\n+\tprt(\"4 / 0 =\", calculator.divide(4, 0))   // impossible to divide by zero\n+\tprt(\"12 / 6 =\", calculator.divide(12, 6)) // 2\n+\tprt()\n+\t_ = calculator.encodeHistory()\n+\tcalculator.saveToFile(calculator.encodeHistory(), \"test.json\")\n+\thistory2 := []byte(`[{\"Num1\":6,\"Operator\":\"add\",\"Num2\":8},{\"Num1\":2,\"Operator\":\"sub\",\"Num2\":7},{\"Num1\":8,\"Operator\":\"mult\",\"Num2\":8},{\"Num1\":33,\"Operator\":\"Div\",\"Num2\":11}]`)\n+\tcalculator.saveToFile(history2, \"test2.json\")\n+\tcalculator.decodeHistory(\"test2.json\")\n+\tcalculator.addToHistory(\"test2.json\")\n+\tcalculator.printHistory()\n+}\n"
                },
                {
                    "date": 1689925988851,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -169,12 +169,12 @@\n }\n \n // ancillary function\n func (c calculator) printHistory() (History []string) {\n-\tfor _, v := range c.history {\n-\t\thistory = append(history, fmt.Sprintf(\"%+v\", v))\n+\tfor _, v := range c.History {\n+\t\tHistory = append(History, fmt.Sprintf(\"%+v\", v))\n \t}\n-\treturn history\n+\treturn History\n }\n \n func main() {\n \tcalculator := calculator{}\n@@ -192,199 +192,4 @@\n \tcalculator.decodeHistory(\"test2.json\")\n \tcalculator.addToHistory(\"test2.json\")\n \tcalculator.printHistory()\n }\n-/*\n-Json allows us to serialize our data to use somewhere else\n-Serialization is also how we can 'save' our work to be used later - think saving in games and then reloading it so you dont have to start from the start\n-\n-In this exercise we will take CalculatorA from the last exercise with the add, mult, divide, and sub functions and add some new functionality to it\n-\n-You might have noticed that Calculators also have some semblance of history of the operations performed - so that is what we will add\n-\n-1. Create a mathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the Calculator. So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n-\n-2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n-\n-3. create an encodeHistory function this will loop over all the mathRequests in the history slice inside the CalculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax\n-\n-so something like this\n-\n-json.Marshal is how you convert a struct into a []byte - and then you can convert []byte into string\n-func (c Calculator) encodeHistory() []string {\n-    for _, mr := range c.history {\n-    }\n-}\n-4. create a decodeHistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the Calculator slice . At the start of this function clear out whatever was in the slice previously\n-\n-json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n-*/\n-\n-package main\n-\n-import (\n-\t\"encoding/json\"\n-\t\"fmt\"\n-\t\"os\"\n-)\n-\n-var prt = fmt.Println\n-\n-/*\n-1. Create a MathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the calculator.\n-So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n-*/\n-\n-type mathRequest struct {\n-\tNum1     int    `json:\"num1\"`\n-\tOperator string `json:\"Operator\"`\n-\tNum2     int    `json:\"num2\"`\n-}\n-\n-/*\n-2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n-*/\n-\n-type calculator struct {\n-\tHistory []mathRequest\n-}\n-\n-func (c calculator) add(num1 int, num2 int) int {\n-\top := mathRequest{num1, \"add\", num2}\n-\tc.History = append(c.History, op)\n-\treturn num1 + num2\n-}\n-\n-func (c calculator) sub(num1 int, num2 int) int {\n-\top := mathRequest{num1, \"sub\", num2}\n-\tc.History = append(c.History, op)\n-\treturn num1 - num2\n-}\n-\n-func (c calculator) mult(num1 int, num2 int) int {\n-\top := mathRequest{num1, \"mult\", num2}\n-\tc.History = append(c.History, op)\n-\treturn num1 * num2\n-}\n-\n-func (c calculator) divide(num1 int, num2 int) int {\n-\tif num2 == 0 {\n-\t\tprt(\"impossible to divide by zero\")\n-\t\treturn 0\n-\t}\n-\top := mathRequest{num1, \"Div\", num2}\n-\tc.History = append(c.History, op)\n-\treturn num1 / num2\n-}\n-\n-/*\n-3. create an encodehistory function this will loop over all the mathRequests in the history slice inside the calculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax. So something like this:\n-func (c calculator) encodehistory() []string {\n-    for _, mr := range c.history {\n-    }\n-}\n-*/\n-\n-func check(e error) (ok bool) {\n-\tif e != nil {\n-\t\tfmt.Printf(\"Error: %s\", e.Error())\n-\t\treturn false\n-\t}\n-\treturn true\n-}\n-\n-func (c calculator) encodeHistory() (eh []byte) {\n-\tprt(c.History)\n-\teh, err := json.Marshal(c.History)\n-\tif !check(err) {\n-\t\treturn nil\n-\t}\n-\treturn eh\n-}\n-\n-func (c calculator) saveToFile(eh []byte, fn string) {\n-\tf, err := os.Create(fn)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\tn2, err := f.Write(eh) // I should check if the file already exists but...\n-\tif !check(err) {\n-\t\tf.Close()\n-\t}\n-\tprt(n2, \"bytes written successfully\")\n-\terr = f.Close()\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\tf2, err := os.ReadFile(fn)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\tprt(\"this is \", fn, \" file: \", string(f2))\n-}\n-\n-/*\n-4. create a decodehistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the calculator slice . At the start of this function clear out whatever was in the slice previously\n-json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n-*/\n-\n-func (c calculator) decodeHistory(fn string) (f []byte) {\n-\tf, err := os.ReadFile(fn)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\t// var data []interface{}\n-\t// err = json.Unmarshal(f, &data)\n-\tmr := make([]mathRequest, 10)\n-\terr = json.Unmarshal(f, &mr)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\treturn f\n-}\n-\n-func (c calculator) addToHistory(fn string) {\n-\tmr := make([]mathRequest, 10)\n-\tf, err := os.ReadFile(fn)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\terr = json.Unmarshal(f, &mr)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\n-\tc.History = nil\n-\t// for _, mRequest := range mr {\n-\t// \tc.history = append(c.history, mathRequest(mRequest))\n-\t// }\n-\tfor _, mRequest := range mr {\n-\t\tc.history = append(c.history, mathRequest(mRequest))\n-\t}\n-\tprt(\"this is the last history:\", c.printHistory())\n-}\n-\n-// ancillary function\n-func (c calculator) printHistory() (history []string) {\n-\tfor _, v := range c.history {\n-\t\thistory = append(history, fmt.Sprintf(\"%+v\", v))\n-\t}\n-\treturn history\n-}\n-\n-func main() {\n-\tcalculator := calculator{}\n-\tprt(\"calculation with calculator:\")\n-\tprt(\"5 + 3 =\", calculator.add(5, 3))      // 8\n-\tprt(\"5 - 9 =\", calculator.sub(5, 9))      // -4\n-\tprt(\"22 * 33 =\", calculator.mult(22, 33)) // 726\n-\tprt(\"4 / 0 =\", calculator.divide(4, 0))   // impossible to divide by zero\n-\tprt(\"12 / 6 =\", calculator.divide(12, 6)) // 2\n-\tprt()\n-\t_ = calculator.encodeHistory()\n-\tcalculator.saveToFile(calculator.encodeHistory(), \"test.json\")\n-\thistory2 := []byte(`[{\"Num1\":6,\"Operator\":\"add\",\"Num2\":8},{\"Num1\":2,\"Operator\":\"sub\",\"Num2\":7},{\"Num1\":8,\"Operator\":\"mult\",\"Num2\":8},{\"Num1\":33,\"Operator\":\"Div\",\"Num2\":11}]`)\n-\tcalculator.saveToFile(history2, \"test2.json\")\n-\tcalculator.decodeHistory(\"test2.json\")\n-\tcalculator.addToHistory(\"test2.json\")\n-\tcalculator.printHistory()\n-}\n"
                },
                {
                    "date": 1689926053409,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,26 +49,26 @@\n 2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n */\n \n type calculator struct {\n-\tHistory []mathRequest\n+\thistory []mathRequest\n }\n \n func (c calculator) add(num1 int, num2 int) int {\n \top := mathRequest{num1, \"add\", num2}\n-\tc.History = append(c.History, op)\n+\tc.history = append(c.history, op)\n \treturn num1 + num2\n }\n \n func (c calculator) sub(num1 int, num2 int) int {\n \top := mathRequest{num1, \"sub\", num2}\n-\tc.History = append(c.History, op)\n+\tc.history = append(c.history, op)\n \treturn num1 - num2\n }\n \n func (c calculator) mult(num1 int, num2 int) int {\n \top := mathRequest{num1, \"mult\", num2}\n-\tc.History = append(c.History, op)\n+\tc.history = append(c.history, op)\n \treturn num1 * num2\n }\n \n func (c calculator) divide(num1 int, num2 int) int {\n@@ -76,9 +76,9 @@\n \t\tprt(\"impossible to divide by zero\")\n \t\treturn 0\n \t}\n \top := mathRequest{num1, \"Div\", num2}\n-\tc.History = append(c.History, op)\n+\tc.history = append(c.history, op)\n \treturn num1 / num2\n }\n \n /*\n@@ -97,10 +97,10 @@\n \treturn true\n }\n \n func (c calculator) encodeHistory() (eh []byte) {\n-\tprt(c.History)\n-\teh, err := json.Marshal(c.History)\n+\tprt(c.history)\n+\teh, err := json.Marshal(c.history)\n \tif !check(err) {\n \t\treturn nil\n \t}\n \treturn eh\n@@ -157,24 +157,24 @@\n \tif !check(err) {\n \t\treturn\n \t}\n \n-\tc.History = nil\n+\tc.history = nil\n \t// for _, mRequest := range mr {\n \t// \tc.history = append(c.history, mathRequest(mRequest))\n \t// }\n \tfor _, mRequest := range mr {\n-\t\tc.History = append(c.History, mathRequest(mRequest))\n+\t\tc.history = append(c.history, mathRequest(mRequest))\n \t}\n \tprt(\"this is the last history:\", c.printHistory())\n }\n \n // ancillary function\n-func (c calculator) printHistory() (History []string) {\n-\tfor _, v := range c.History {\n-\t\tHistory = append(History, fmt.Sprintf(\"%+v\", v))\n+func (c calculator) printHistory() (history []string) {\n+\tfor _, v := range c.history {\n+\t\thistory = append(history, fmt.Sprintf(\"%+v\", v))\n \t}\n-\treturn History\n+\treturn history\n }\n \n func main() {\n \tcalculator := calculator{}\n"
                },
                {
                    "date": 1689926060652,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,195 @@\n+/*\n+Json allows us to serialize our data to use somewhere else\n+Serialization is also how we can 'save' our work to be used later - think saving in games and then reloading it so you dont have to start from the start\n+\n+In this exercise we will take CalculatorA from the last exercise with the add, mult, divide, and sub functions and add some new functionality to it\n+\n+You might have noticed that Calculators also have some semblance of history of the operations performed - so that is what we will add\n+\n+1. Create a mathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the Calculator. So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n+\n+2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n+\n+3. create an encodeHistory function this will loop over all the mathRequests in the history slice inside the CalculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax\n+\n+so something like this\n+\n+json.Marshal is how you convert a struct into a []byte - and then you can convert []byte into string\n+func (c Calculator) encodeHistory() []string {\n+    for _, mr := range c.history {\n+    }\n+}\n+4. create a decodeHistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the Calculator slice . At the start of this function clear out whatever was in the slice previously\n+\n+json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n+*/\n+\n+package main\n+\n+import (\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"os\"\n+)\n+\n+var prt = fmt.Println\n+\n+/*\n+1. Create a MathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the calculator.\n+So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n+*/\n+\n+type mathRequest struct {\n+\tNum1     int    `json:\"num1\"`\n+\tOperator string `json:\"Operator\"`\n+\tNum2     int    `json:\"num2\"`\n+}\n+\n+/*\n+2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n+*/\n+\n+type calculator struct {\n+\thistory []mathRequest\n+}\n+\n+func (c calculator) add(num1 int, num2 int) int {\n+\top := mathRequest{num1, \"add\", num2}\n+\tc.history = append(c.history, op)\n+\treturn num1 + num2\n+}\n+a\n+func (c calculator) sub(num1 int, num2 int) int {\n+\top := mathRequest{num1, \"sub\", num2}\n+\tc.history = append(c.history, op)\n+\treturn num1 - num2\n+}\n+\n+func (c calculator) mult(num1 int, num2 int) int {\n+\top := mathRequest{num1, \"mult\", num2}\n+\tc.history = append(c.history, op)\n+\treturn num1 * num2\n+}\n+\n+func (c calculator) divide(num1 int, num2 int) int {\n+\tif num2 == 0 {\n+\t\tprt(\"impossible to divide by zero\")\n+\t\treturn 0\n+\t}\n+\top := mathRequest{num1, \"Div\", num2}\n+\tc.history = append(c.history, op)\n+\treturn num1 / num2\n+}\n+\n+/*\n+3. create an encodehistory function this will loop over all the mathRequests in the history slice inside the calculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax. So something like this:\n+func (c calculator) encodehistory() []string {\n+    for _, mr := range c.history {\n+    }\n+}\n+*/\n+\n+func check(e error) (ok bool) {\n+\tif e != nil {\n+\t\tfmt.Printf(\"Error: %s\", e.Error())\n+\t\treturn false\n+\t}\n+\treturn true\n+}\n+\n+func (c calculator) encodeHistory() (eh []byte) {\n+\tprt(c.history)\n+\teh, err := json.Marshal(c.history)\n+\tif !check(err) {\n+\t\treturn nil\n+\t}\n+\treturn eh\n+}\n+\n+func (c calculator) saveToFile(eh []byte, fn string) {\n+\tf, err := os.Create(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\tn2, err := f.Write(eh) // I should check if the file already exists but...\n+\tif !check(err) {\n+\t\tf.Close()\n+\t}\n+\tprt(n2, \"bytes written successfully\")\n+\terr = f.Close()\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\tf2, err := os.ReadFile(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\tprt(\"this is \", fn, \" file: \", string(f2))\n+}\n+\n+/*\n+4. create a decodehistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the calculator slice . At the start of this function clear out whatever was in the slice previously\n+json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n+*/\n+\n+func (c calculator) decodeHistory(fn string) (f []byte) {\n+\tf, err := os.ReadFile(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\t// var data []interface{}\n+\t// err = json.Unmarshal(f, &data)\n+\tmr := make([]mathRequest, 10)\n+\terr = json.Unmarshal(f, &mr)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\treturn f\n+}\n+\n+func (c calculator) addToHistory(fn string) {\n+\tmr := make([]mathRequest, 10)\n+\tf, err := os.ReadFile(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\terr = json.Unmarshal(f, &mr)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\n+\tc.history = nil\n+\t// for _, mRequest := range mr {\n+\t// \tc.history = append(c.history, mathRequest(mRequest))\n+\t// }\n+\tfor _, mRequest := range mr {\n+\t\tc.history = append(c.history, mathRequest(mRequest))\n+\t}\n+\tprt(\"this is the last history:\", c.printHistory())\n+}\n+\n+// ancillary function\n+func (c calculator) printHistory() (history []string) {\n+\tfor _, v := range c.history {\n+\t\thistory = append(history, fmt.Sprintf(\"%+v\", v))\n+\t}\n+\treturn history\n+}\n+\n+func main() {\n+\tcalculator := calculator{}\n+\tprt(\"calculation with calculator:\")\n+\tprt(\"5 + 3 =\", calculator.add(5, 3))      // 8\n+\tprt(\"5 - 9 =\", calculator.sub(5, 9))      // -4\n+\tprt(\"22 * 33 =\", calculator.mult(22, 33)) // 726\n+\tprt(\"4 / 0 =\", calculator.divide(4, 0))   // impossible to divide by zero\n+\tprt(\"12 / 6 =\", calculator.divide(12, 6)) // 2\n+\tprt()\n+\t_ = calculator.encodeHistory()\n+\tcalculator.saveToFile(calculator.encodeHistory(), \"test.json\")\n+\thistory2 := []byte(`[{\"Num1\":6,\"Operator\":\"add\",\"Num2\":8},{\"Num1\":2,\"Operator\":\"sub\",\"Num2\":7},{\"Num1\":8,\"Operator\":\"mult\",\"Num2\":8},{\"Num1\":33,\"Operator\":\"Div\",\"Num2\":11}]`)\n+\tcalculator.saveToFile(history2, \"test2.json\")\n+\tcalculator.decodeHistory(\"test2.json\")\n+\tcalculator.addToHistory(\"test2.json\")\n+\tcalculator.printHistory()\n+}\n"
                },
                {
                    "date": 1689926069698,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -57,204 +57,9 @@\n \top := mathRequest{num1, \"add\", num2}\n \tc.history = append(c.history, op)\n \treturn num1 + num2\n }\n-a\n-func (c calculator) sub(num1 int, num2 int) int {\n-\top := mathRequest{num1, \"sub\", num2}\n-\tc.history = append(c.history, op)\n-\treturn num1 - num2\n-}\n \n-func (c calculator) mult(num1 int, num2 int) int {\n-\top := mathRequest{num1, \"mult\", num2}\n-\tc.history = append(c.history, op)\n-\treturn num1 * num2\n-}\n-\n-func (c calculator) divide(num1 int, num2 int) int {\n-\tif num2 == 0 {\n-\t\tprt(\"impossible to divide by zero\")\n-\t\treturn 0\n-\t}\n-\top := mathRequest{num1, \"Div\", num2}\n-\tc.history = append(c.history, op)\n-\treturn num1 / num2\n-}\n-\n-/*\n-3. create an encodehistory function this will loop over all the mathRequests in the history slice inside the calculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax. So something like this:\n-func (c calculator) encodehistory() []string {\n-    for _, mr := range c.history {\n-    }\n-}\n-*/\n-\n-func check(e error) (ok bool) {\n-\tif e != nil {\n-\t\tfmt.Printf(\"Error: %s\", e.Error())\n-\t\treturn false\n-\t}\n-\treturn true\n-}\n-\n-func (c calculator) encodeHistory() (eh []byte) {\n-\tprt(c.history)\n-\teh, err := json.Marshal(c.history)\n-\tif !check(err) {\n-\t\treturn nil\n-\t}\n-\treturn eh\n-}\n-\n-func (c calculator) saveToFile(eh []byte, fn string) {\n-\tf, err := os.Create(fn)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\tn2, err := f.Write(eh) // I should check if the file already exists but...\n-\tif !check(err) {\n-\t\tf.Close()\n-\t}\n-\tprt(n2, \"bytes written successfully\")\n-\terr = f.Close()\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\tf2, err := os.ReadFile(fn)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\tprt(\"this is \", fn, \" file: \", string(f2))\n-}\n-\n-/*\n-4. create a decodehistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the calculator slice . At the start of this function clear out whatever was in the slice previously\n-json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n-*/\n-\n-func (c calculator) decodeHistory(fn string) (f []byte) {\n-\tf, err := os.ReadFile(fn)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\t// var data []interface{}\n-\t// err = json.Unmarshal(f, &data)\n-\tmr := make([]mathRequest, 10)\n-\terr = json.Unmarshal(f, &mr)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\treturn f\n-}\n-\n-func (c calculator) addToHistory(fn string) {\n-\tmr := make([]mathRequest, 10)\n-\tf, err := os.ReadFile(fn)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\terr = json.Unmarshal(f, &mr)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\n-\tc.history = nil\n-\t// for _, mRequest := range mr {\n-\t// \tc.history = append(c.history, mathRequest(mRequest))\n-\t// }\n-\tfor _, mRequest := range mr {\n-\t\tc.history = append(c.history, mathRequest(mRequest))\n-\t}\n-\tprt(\"this is the last history:\", c.printHistory())\n-}\n-\n-// ancillary function\n-func (c calculator) printHistory() (history []string) {\n-\tfor _, v := range c.history {\n-\t\thistory = append(history, fmt.Sprintf(\"%+v\", v))\n-\t}\n-\treturn history\n-}\n-\n-func main() {\n-\tcalculator := calculator{}\n-\tprt(\"calculation with calculator:\")\n-\tprt(\"5 + 3 =\", calculator.add(5, 3))      // 8\n-\tprt(\"5 - 9 =\", calculator.sub(5, 9))      // -4\n-\tprt(\"22 * 33 =\", calculator.mult(22, 33)) // 726\n-\tprt(\"4 / 0 =\", calculator.divide(4, 0))   // impossible to divide by zero\n-\tprt(\"12 / 6 =\", calculator.divide(12, 6)) // 2\n-\tprt()\n-\t_ = calculator.encodeHistory()\n-\tcalculator.saveToFile(calculator.encodeHistory(), \"test.json\")\n-\thistory2 := []byte(`[{\"Num1\":6,\"Operator\":\"add\",\"Num2\":8},{\"Num1\":2,\"Operator\":\"sub\",\"Num2\":7},{\"Num1\":8,\"Operator\":\"mult\",\"Num2\":8},{\"Num1\":33,\"Operator\":\"Div\",\"Num2\":11}]`)\n-\tcalculator.saveToFile(history2, \"test2.json\")\n-\tcalculator.decodeHistory(\"test2.json\")\n-\tcalculator.addToHistory(\"test2.json\")\n-\tcalculator.printHistory()\n-}\n-/*\n-Json allows us to serialize our data to use somewhere else\n-Serialization is also how we can 'save' our work to be used later - think saving in games and then reloading it so you dont have to start from the start\n-\n-In this exercise we will take CalculatorA from the last exercise with the add, mult, divide, and sub functions and add some new functionality to it\n-\n-You might have noticed that Calculators also have some semblance of history of the operations performed - so that is what we will add\n-\n-1. Create a mathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the Calculator. So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n-\n-2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n-\n-3. create an encodeHistory function this will loop over all the mathRequests in the history slice inside the CalculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax\n-\n-so something like this\n-\n-json.Marshal is how you convert a struct into a []byte - and then you can convert []byte into string\n-func (c Calculator) encodeHistory() []string {\n-    for _, mr := range c.history {\n-    }\n-}\n-4. create a decodeHistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the Calculator slice . At the start of this function clear out whatever was in the slice previously\n-\n-json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n-*/\n-\n-package main\n-\n-import (\n-\t\"encoding/json\"\n-\t\"fmt\"\n-\t\"os\"\n-)\n-\n-var prt = fmt.Println\n-\n-/*\n-1. Create a MathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the calculator.\n-So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n-*/\n-\n-type mathRequest struct {\n-\tNum1     int    `json:\"num1\"`\n-\tOperator string `json:\"Operator\"`\n-\tNum2     int    `json:\"num2\"`\n-}\n-\n-/*\n-2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n-*/\n-\n-type calculator struct {\n-\thistory []mathRequest\n-}\n-\n-func (c calculator) add(num1 int, num2 int) int {\n-\top := mathRequest{num1, \"add\", num2}\n-\tc.history = append(c.history, op)\n-\treturn num1 + num2\n-}\n-\n func (c calculator) sub(num1 int, num2 int) int {\n \top := mathRequest{num1, \"sub\", num2}\n \tc.history = append(c.history, op)\n \treturn num1 - num2\n"
                },
                {
                    "date": 1689926167106,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,9 +48,9 @@\n /*\n 2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n */\n \n-type calculator struct {\n+type Calculator struct {\n \thistory []mathRequest\n }\n \n func (c calculator) add(num1 int, num2 int) int {\n"
                },
                {
                    "date": 1689926177117,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,27 +52,27 @@\n type Calculator struct {\n \thistory []mathRequest\n }\n \n-func (c calculator) add(num1 int, num2 int) int {\n+func (c Calculator) add(num1 int, num2 int) int {\n \top := mathRequest{num1, \"add\", num2}\n \tc.history = append(c.history, op)\n \treturn num1 + num2\n }\n \n-func (c calculator) sub(num1 int, num2 int) int {\n+func (c Calculator) sub(num1 int, num2 int) int {\n \top := mathRequest{num1, \"sub\", num2}\n \tc.history = append(c.history, op)\n \treturn num1 - num2\n }\n \n-func (c calculator) mult(num1 int, num2 int) int {\n+func (c Calculator) mult(num1 int, num2 int) int {\n \top := mathRequest{num1, \"mult\", num2}\n \tc.history = append(c.history, op)\n \treturn num1 * num2\n }\n \n-func (c calculator) divide(num1 int, num2 int) int {\n+func (c Calculator) divide(num1 int, num2 int) int {\n \tif num2 == 0 {\n \t\tprt(\"impossible to divide by zero\")\n \t\treturn 0\n \t}\n@@ -82,9 +82,9 @@\n }\n \n /*\n 3. create an encodehistory function this will loop over all the mathRequests in the history slice inside the calculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax. So something like this:\n-func (c calculator) encodehistory() []string {\n+func (c Calculator) encodehistory() []string {\n     for _, mr := range c.history {\n     }\n }\n */\n"
                },
                {
                    "date": 1689926182731,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -96,18 +96,18 @@\n \t}\n \treturn true\n }\n \n-func (c calculator) encodeHistory() (eh []byte) {\n+func (c Calculator) encodeHistory() (eh []byte) {\n \tprt(c.history)\n \teh, err := json.Marshal(c.history)\n \tif !check(err) {\n \t\treturn nil\n \t}\n \treturn eh\n }\n \n-func (c calculator) saveToFile(eh []byte, fn string) {\n+func (c Calculator) saveToFile(eh []byte, fn string) {\n \tf, err := os.Create(fn)\n \tif !check(err) {\n \t\treturn\n \t}\n@@ -127,13 +127,13 @@\n \tprt(\"this is \", fn, \" file: \", string(f2))\n }\n \n /*\n-4. create a decodehistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the calculator slice . At the start of this function clear out whatever was in the slice previously\n+4. create a decodehistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the Calculator slice . At the start of this function clear out whatever was in the slice previously\n json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n */\n \n-func (c calculator) decodeHistory(fn string) (f []byte) {\n+func (c Calculator) decodeHistory(fn string) (f []byte) {\n \tf, err := os.ReadFile(fn)\n \tif !check(err) {\n \t\treturn\n \t}\n@@ -146,9 +146,9 @@\n \t}\n \treturn f\n }\n \n-func (c calculator) addToHistory(fn string) {\n+func (c Calculator) addToHistory(fn string) {\n \tmr := make([]mathRequest, 10)\n \tf, err := os.ReadFile(fn)\n \tif !check(err) {\n \t\treturn\n@@ -168,9 +168,9 @@\n \tprt(\"this is the last history:\", c.printHistory())\n }\n \n // ancillary function\n-func (c calculator) printHistory() (history []string) {\n+func (c Calculator) printHistory() (history []string) {\n \tfor _, v := range c.history {\n \t\thistory = append(history, fmt.Sprintf(\"%+v\", v))\n \t}\n \treturn history\n"
                },
                {
                    "date": 1689926187821,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -176,9 +176,9 @@\n \treturn history\n }\n \n func main() {\n-\tcalculator := calculator{}\n+\tcalculator := Calculator{}\n \tprt(\"calculation with calculator:\")\n \tprt(\"5 + 3 =\", calculator.add(5, 3))      // 8\n \tprt(\"5 - 9 =\", calculator.sub(5, 9))      // -4\n \tprt(\"22 * 33 =\", calculator.mult(22, 33)) // 726\n"
                },
                {
                    "date": 1689926196949,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,195 @@\n+/*\n+Json allows us to serialize our data to use somewhere else\n+Serialization is also how we can 'save' our work to be used later - think saving in games and then reloading it so you dont have to start from the start\n+\n+In this exercise we will take CalculatorA from the last exercise with the add, mult, divide, and sub functions and add some new functionality to it\n+\n+You might have noticed that Calculators also have some semblance of history of the operations performed - so that is what we will add\n+\n+1. Create a mathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the Calculator. So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n+\n+2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n+\n+3. create an encodeHistory function this will loop over all the mathRequests in the history slice inside the CalculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax\n+\n+so something like this\n+\n+json.Marshal is how you convert a struct into a []byte - and then you can convert []byte into string\n+func (c Calculator) encodeHistory() []string {\n+    for _, mr := range c.history {\n+    }\n+}\n+4. create a decodeHistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the Calculator slice . At the start of this function clear out whatever was in the slice previously\n+\n+json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n+*/\n+\n+package main\n+\n+import (\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"os\"\n+)\n+\n+var prt = fmt.Println\n+\n+/*\n+1. Create a MathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the calculator.\n+So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n+*/\n+\n+type mathRequest struct {\n+\tNum1     int    `json:\"num1\"`\n+\tOperator string `json:\"Operator\"`\n+\tNum2     int    `json:\"num2\"`\n+}\n+\n+/*\n+2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n+*/\n+\n+type Calculator struct {\n+\thistory []mathRequest\n+}\n+\n+func (c Calculator) add(num1 int, num2 int) int {\n+\top := mathRequest{num1, \"add\", num2}\n+\tc.history = append(c.history, op)\n+\treturn num1 + num2\n+}\n+\n+func (c Calculator) sub(num1 int, num2 int) int {\n+\top := mathRequest{num1, \"sub\", num2}\n+\tc.history = append(c.history, op)\n+\treturn num1 - num2\n+}\n+\n+func (c Calculator) mult(num1 int, num2 int) int {\n+\top := mathRequest{num1, \"mult\", num2}\n+\tc.history = append(c.history, op)\n+\treturn num1 * num2\n+}\n+\n+func (c Calculator) divide(num1 int, num2 int) int {\n+\tif num2 == 0 {\n+\t\tprt(\"impossible to divide by zero\")\n+\t\treturn 0\n+\t}\n+\top := mathRequest{num1, \"Div\", num2}\n+\tc.history = append(c.history, op)\n+\treturn num1 / num2\n+}\n+\n+/*\n+3. create an encodehistory function this will loop over all the mathRequests in the history slice inside the calculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax. So something like this:\n+func (c Calculator) encodehistory() []string {\n+    for _, mr := range c.history {\n+    }\n+}\n+*/\n+\n+func check(e error) (ok bool) {\n+\tif e != nil {\n+\t\tfmt.Printf(\"Error: %s\", e.Error())\n+\t\treturn false\n+\t}\n+\treturn true\n+}\n+\n+func (c Calculator) encodeHistory() (eh []byte) {\n+\tprt(c.history)\n+\teh, err := json.Marshal(c.history)\n+\tif !check(err) {\n+\t\treturn nil\n+\t}\n+\treturn eh\n+}\n+\n+func (c Calculator) saveToFile(eh []byte, fn string) {\n+\tf, err := os.Create(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\tn2, err := f.Write(eh) // I should check if the file already exists but...\n+\tif !check(err) {\n+\t\tf.Close()\n+\t}\n+\tprt(n2, \"bytes written successfully\")\n+\terr = f.Close()\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\tf2, err := os.ReadFile(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\tprt(\"this is \", fn, \" file: \", string(f2))\n+}\n+\n+/*\n+4. create a decodehistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the Calculator slice . At the start of this function clear out whatever was in the slice previously\n+json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n+*/\n+\n+func (c Calculator) decodeHistory(fn string) (f []byte) {\n+\tf, err := os.ReadFile(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\t// var data []interface{}\n+\t// err = json.Unmarshal(f, &data)\n+\tmr := make([]mathRequest, 10)\n+\terr = json.Unmarshal(f, &mr)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\treturn f\n+}\n+\n+func (c Calculator) addToHistory(fn string) {\n+\tmr := make([]mathRequest, 10)\n+\tf, err := os.ReadFile(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\terr = json.Unmarshal(f, &mr)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\n+\tc.history = nil\n+\t// for _, mRequest := range mr {\n+\t// \tc.history = append(c.history, mathRequest(mRequest))\n+\t// }\n+\tfor _, mRequest := range mr {\n+\t\tc.history = append(c.history, mathRequest(mRequest))\n+\t}\n+\tprt(\"this is the last history:\", c.printHistory())\n+}\n+\n+// ancillary function\n+func (c Calculator) printHistory() (history []string) {\n+\tfor _, v := range c.history {\n+\t\thistory = append(history, fmt.Sprintf(\"%+v\", v))\n+\t}\n+\treturn history\n+}\n+\n+func main() {\n+\tcalc := Calculator{}\n+\tprt(\"calculation with calculator:\")\n+\tprt(\"5 + 3 =\", calculator.add(5, 3))      // 8\n+\tprt(\"5 - 9 =\", calculator.sub(5, 9))      // -4\n+\tprt(\"22 * 33 =\", calculator.mult(22, 33)) // 726\n+\tprt(\"4 / 0 =\", calculator.divide(4, 0))   // impossible to divide by zero\n+\tprt(\"12 / 6 =\", calculator.divide(12, 6)) // 2\n+\tprt()\n+\t_ = calculator.encodeHistory()\n+\tcalculator.saveToFile(calculator.encodeHistory(), \"test.json\")\n+\thistory2 := []byte(`[{\"Num1\":6,\"Operator\":\"add\",\"Num2\":8},{\"Num1\":2,\"Operator\":\"sub\",\"Num2\":7},{\"Num1\":8,\"Operator\":\"mult\",\"Num2\":8},{\"Num1\":33,\"Operator\":\"Div\",\"Num2\":11}]`)\n+\tcalculator.saveToFile(history2, \"test2.json\")\n+\tcalculator.decodeHistory(\"test2.json\")\n+\tcalculator.addToHistory(\"test2.json\")\n+\tcalculator.printHistory()\n+}\n"
                },
                {
                    "date": 1689926207441,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -178,213 +178,18 @@\n \n func main() {\n \tcalc := Calculator{}\n \tprt(\"calculation with calculator:\")\n-\tprt(\"5 + 3 =\", calculator.add(5, 3))      // 8\n-\tprt(\"5 - 9 =\", calculator.sub(5, 9))      // -4\n-\tprt(\"22 * 33 =\", calculator.mult(22, 33)) // 726\n-\tprt(\"4 / 0 =\", calculator.divide(4, 0))   // impossible to divide by zero\n-\tprt(\"12 / 6 =\", calculator.divide(12, 6)) // 2\n+\tprt(\"5 + 3 =\", calc.add(5, 3))      // 8\n+\tprt(\"5 - 9 =\", calc.sub(5, 9))      // -4\n+\tprt(\"22 * 33 =\", calc.mult(22, 33)) // 726\n+\tprt(\"4 / 0 =\", calc.divide(4, 0))   // impossible to divide by zero\n+\tprt(\"12 / 6 =\", calc.divide(12, 6)) // 2\n \tprt()\n-\t_ = calculator.encodeHistory()\n-\tcalculator.saveToFile(calculator.encodeHistory(), \"test.json\")\n+\t_ = calc.encodeHistory()\n+\tcalc.saveToFile(calc.encodeHistory(), \"test.json\")\n \thistory2 := []byte(`[{\"Num1\":6,\"Operator\":\"add\",\"Num2\":8},{\"Num1\":2,\"Operator\":\"sub\",\"Num2\":7},{\"Num1\":8,\"Operator\":\"mult\",\"Num2\":8},{\"Num1\":33,\"Operator\":\"Div\",\"Num2\":11}]`)\n \tcalculator.saveToFile(history2, \"test2.json\")\n \tcalculator.decodeHistory(\"test2.json\")\n \tcalculator.addToHistory(\"test2.json\")\n \tcalculator.printHistory()\n }\n-/*\n-Json allows us to serialize our data to use somewhere else\n-Serialization is also how we can 'save' our work to be used later - think saving in games and then reloading it so you dont have to start from the start\n-\n-In this exercise we will take CalculatorA from the last exercise with the add, mult, divide, and sub functions and add some new functionality to it\n-\n-You might have noticed that Calculators also have some semblance of history of the operations performed - so that is what we will add\n-\n-1. Create a mathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the Calculator. So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n-\n-2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n-\n-3. create an encodeHistory function this will loop over all the mathRequests in the history slice inside the CalculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax\n-\n-so something like this\n-\n-json.Marshal is how you convert a struct into a []byte - and then you can convert []byte into string\n-func (c Calculator) encodeHistory() []string {\n-    for _, mr := range c.history {\n-    }\n-}\n-4. create a decodeHistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the Calculator slice . At the start of this function clear out whatever was in the slice previously\n-\n-json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n-*/\n-\n-package main\n-\n-import (\n-\t\"encoding/json\"\n-\t\"fmt\"\n-\t\"os\"\n-)\n-\n-var prt = fmt.Println\n-\n-/*\n-1. Create a MathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the calculator.\n-So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n-*/\n-\n-type mathRequest struct {\n-\tNum1     int    `json:\"num1\"`\n-\tOperator string `json:\"Operator\"`\n-\tNum2     int    `json:\"num2\"`\n-}\n-\n-/*\n-2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n-*/\n-\n-type Calculator struct {\n-\thistory []mathRequest\n-}\n-\n-func (c Calculator) add(num1 int, num2 int) int {\n-\top := mathRequest{num1, \"add\", num2}\n-\tc.history = append(c.history, op)\n-\treturn num1 + num2\n-}\n-\n-func (c Calculator) sub(num1 int, num2 int) int {\n-\top := mathRequest{num1, \"sub\", num2}\n-\tc.history = append(c.history, op)\n-\treturn num1 - num2\n-}\n-\n-func (c Calculator) mult(num1 int, num2 int) int {\n-\top := mathRequest{num1, \"mult\", num2}\n-\tc.history = append(c.history, op)\n-\treturn num1 * num2\n-}\n-\n-func (c Calculator) divide(num1 int, num2 int) int {\n-\tif num2 == 0 {\n-\t\tprt(\"impossible to divide by zero\")\n-\t\treturn 0\n-\t}\n-\top := mathRequest{num1, \"Div\", num2}\n-\tc.history = append(c.history, op)\n-\treturn num1 / num2\n-}\n-\n-/*\n-3. create an encodehistory function this will loop over all the mathRequests in the history slice inside the calculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax. So something like this:\n-func (c Calculator) encodehistory() []string {\n-    for _, mr := range c.history {\n-    }\n-}\n-*/\n-\n-func check(e error) (ok bool) {\n-\tif e != nil {\n-\t\tfmt.Printf(\"Error: %s\", e.Error())\n-\t\treturn false\n-\t}\n-\treturn true\n-}\n-\n-func (c Calculator) encodeHistory() (eh []byte) {\n-\tprt(c.history)\n-\teh, err := json.Marshal(c.history)\n-\tif !check(err) {\n-\t\treturn nil\n-\t}\n-\treturn eh\n-}\n-\n-func (c Calculator) saveToFile(eh []byte, fn string) {\n-\tf, err := os.Create(fn)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\tn2, err := f.Write(eh) // I should check if the file already exists but...\n-\tif !check(err) {\n-\t\tf.Close()\n-\t}\n-\tprt(n2, \"bytes written successfully\")\n-\terr = f.Close()\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\tf2, err := os.ReadFile(fn)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\tprt(\"this is \", fn, \" file: \", string(f2))\n-}\n-\n-/*\n-4. create a decodehistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the Calculator slice . At the start of this function clear out whatever was in the slice previously\n-json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n-*/\n-\n-func (c Calculator) decodeHistory(fn string) (f []byte) {\n-\tf, err := os.ReadFile(fn)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\t// var data []interface{}\n-\t// err = json.Unmarshal(f, &data)\n-\tmr := make([]mathRequest, 10)\n-\terr = json.Unmarshal(f, &mr)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\treturn f\n-}\n-\n-func (c Calculator) addToHistory(fn string) {\n-\tmr := make([]mathRequest, 10)\n-\tf, err := os.ReadFile(fn)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\terr = json.Unmarshal(f, &mr)\n-\tif !check(err) {\n-\t\treturn\n-\t}\n-\n-\tc.history = nil\n-\t// for _, mRequest := range mr {\n-\t// \tc.history = append(c.history, mathRequest(mRequest))\n-\t// }\n-\tfor _, mRequest := range mr {\n-\t\tc.history = append(c.history, mathRequest(mRequest))\n-\t}\n-\tprt(\"this is the last history:\", c.printHistory())\n-}\n-\n-// ancillary function\n-func (c Calculator) printHistory() (history []string) {\n-\tfor _, v := range c.history {\n-\t\thistory = append(history, fmt.Sprintf(\"%+v\", v))\n-\t}\n-\treturn history\n-}\n-\n-func main() {\n-\tcalculator := Calculator{}\n-\tprt(\"calculation with calculator:\")\n-\tprt(\"5 + 3 =\", calculator.add(5, 3))      // 8\n-\tprt(\"5 - 9 =\", calculator.sub(5, 9))      // -4\n-\tprt(\"22 * 33 =\", calculator.mult(22, 33)) // 726\n-\tprt(\"4 / 0 =\", calculator.divide(4, 0))   // impossible to divide by zero\n-\tprt(\"12 / 6 =\", calculator.divide(12, 6)) // 2\n-\tprt()\n-\t_ = calculator.encodeHistory()\n-\tcalculator.saveToFile(calculator.encodeHistory(), \"test.json\")\n-\thistory2 := []byte(`[{\"Num1\":6,\"Operator\":\"add\",\"Num2\":8},{\"Num1\":2,\"Operator\":\"sub\",\"Num2\":7},{\"Num1\":8,\"Operator\":\"mult\",\"Num2\":8},{\"Num1\":33,\"Operator\":\"Div\",\"Num2\":11}]`)\n-\tcalculator.saveToFile(history2, \"test2.json\")\n-\tcalculator.decodeHistory(\"test2.json\")\n-\tcalculator.addToHistory(\"test2.json\")\n-\tcalculator.printHistory()\n-}\n"
                },
                {
                    "date": 1689926214784,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -176,18 +176,18 @@\n \treturn history\n }\n \n func main() {\n-\tcalc := Calculator{}\n+\tcalculator := Calculator{}\n \tprt(\"calculation with calculator:\")\n-\tprt(\"5 + 3 =\", calc.add(5, 3))      // 8\n-\tprt(\"5 - 9 =\", calc.sub(5, 9))      // -4\n-\tprt(\"22 * 33 =\", calc.mult(22, 33)) // 726\n-\tprt(\"4 / 0 =\", calc.divide(4, 0))   // impossible to divide by zero\n-\tprt(\"12 / 6 =\", calc.divide(12, 6)) // 2\n+\tprt(\"5 + 3 =\", calculator.add(5, 3))      // 8\n+\tprt(\"5 - 9 =\", calculator.sub(5, 9))      // -4\n+\tprt(\"22 * 33 =\", calculator.mult(22, 33)) // 726\n+\tprt(\"4 / 0 =\", calculator.divide(4, 0))   // impossible to divide by zero\n+\tprt(\"12 / 6 =\", calculator.divide(12, 6)) // 2\n \tprt()\n-\t_ = calc.encodeHistory()\n-\tcalc.saveToFile(calc.encodeHistory(), \"test.json\")\n+\t_ = calculator.encodeHistory()\n+\tcalculator.saveToFile(calculator.encodeHistory(), \"test.json\")\n \thistory2 := []byte(`[{\"Num1\":6,\"Operator\":\"add\",\"Num2\":8},{\"Num1\":2,\"Operator\":\"sub\",\"Num2\":7},{\"Num1\":8,\"Operator\":\"mult\",\"Num2\":8},{\"Num1\":33,\"Operator\":\"Div\",\"Num2\":11}]`)\n \tcalculator.saveToFile(history2, \"test2.json\")\n \tcalculator.decodeHistory(\"test2.json\")\n \tcalculator.addToHistory(\"test2.json\")\n"
                },
                {
                    "date": 1689926232354,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -82,9 +82,9 @@\n }\n \n /*\n 3. create an encodehistory function this will loop over all the mathRequests in the history slice inside the calculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax. So something like this:\n-func (c Calculator) encodehistory() []string {\n+func (c calculator) encodehistory() []string {\n     for _, mr := range c.history {\n     }\n }\n */\n@@ -96,18 +96,18 @@\n \t}\n \treturn true\n }\n \n-func (c Calculator) encodeHistory() (eh []byte) {\n+func (c calculator) encodeHistory() (eh []byte) {\n \tprt(c.history)\n \teh, err := json.Marshal(c.history)\n \tif !check(err) {\n \t\treturn nil\n \t}\n \treturn eh\n }\n \n-func (c Calculator) saveToFile(eh []byte, fn string) {\n+func (c calculator) saveToFile(eh []byte, fn string) {\n \tf, err := os.Create(fn)\n \tif !check(err) {\n \t\treturn\n \t}\n@@ -127,13 +127,13 @@\n \tprt(\"this is \", fn, \" file: \", string(f2))\n }\n \n /*\n-4. create a decodehistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the Calculator slice . At the start of this function clear out whatever was in the slice previously\n+4. create a decodehistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the calculator slice . At the start of this function clear out whatever was in the slice previously\n json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n */\n \n-func (c Calculator) decodeHistory(fn string) (f []byte) {\n+func (c calculator) decodeHistory(fn string) (f []byte) {\n \tf, err := os.ReadFile(fn)\n \tif !check(err) {\n \t\treturn\n \t}\n@@ -146,9 +146,9 @@\n \t}\n \treturn f\n }\n \n-func (c Calculator) addToHistory(fn string) {\n+func (c calculator) addToHistory(fn string) {\n \tmr := make([]mathRequest, 10)\n \tf, err := os.ReadFile(fn)\n \tif !check(err) {\n \t\treturn\n@@ -168,17 +168,17 @@\n \tprt(\"this is the last history:\", c.printHistory())\n }\n \n // ancillary function\n-func (c Calculator) printHistory() (history []string) {\n+func (c calculator) printHistory() (history []string) {\n \tfor _, v := range c.history {\n \t\thistory = append(history, fmt.Sprintf(\"%+v\", v))\n \t}\n \treturn history\n }\n \n func main() {\n-\tcalculator := Calculator{}\n+\tcalculator := calculator{}\n \tprt(\"calculation with calculator:\")\n \tprt(\"5 + 3 =\", calculator.add(5, 3))      // 8\n \tprt(\"5 - 9 =\", calculator.sub(5, 9))      // -4\n \tprt(\"22 * 33 =\", calculator.mult(22, 33)) // 726\n"
                },
                {
                    "date": 1689926240190,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -48,31 +48,31 @@\n /*\n 2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n */\n \n-type Calculator struct {\n+type calculator struct {\n \thistory []mathRequest\n }\n \n-func (c Calculator) add(num1 int, num2 int) int {\n+func (c calculator) add(num1 int, num2 int) int {\n \top := mathRequest{num1, \"add\", num2}\n \tc.history = append(c.history, op)\n \treturn num1 + num2\n }\n \n-func (c Calculator) sub(num1 int, num2 int) int {\n+func (c calculator) sub(num1 int, num2 int) int {\n \top := mathRequest{num1, \"sub\", num2}\n \tc.history = append(c.history, op)\n \treturn num1 - num2\n }\n \n-func (c Calculator) mult(num1 int, num2 int) int {\n+func (c calculator) mult(num1 int, num2 int) int {\n \top := mathRequest{num1, \"mult\", num2}\n \tc.history = append(c.history, op)\n \treturn num1 * num2\n }\n \n-func (c Calculator) divide(num1 int, num2 int) int {\n+func (c calculator) divide(num1 int, num2 int) int {\n \tif num2 == 0 {\n \t\tprt(\"impossible to divide by zero\")\n \t\treturn 0\n \t}\n"
                },
                {
                    "date": 1689926382108,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -40,9 +40,9 @@\n */\n \n type mathRequest struct {\n \tNum1     int    `json:\"num1\"`\n-\tOperator string `json:\"Operator\"`\n+\tOperator string `json:\"operator\"`\n \tNum2     int    `json:\"num2\"`\n }\n \n /*\n"
                },
                {
                    "date": 1689926388587,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -39,9 +39,9 @@\n So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n */\n \n type mathRequest struct {\n-\tNum1     int    `json:\"num1\"`\n+\tNum1     int    `json:\"Num1\"`\n \tOperator string `json:\"operator\"`\n \tNum2     int    `json:\"num2\"`\n }\n \n"
                },
                {
                    "date": 1689926394188,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -40,10 +40,10 @@\n */\n \n type mathRequest struct {\n \tNum1     int    `json:\"Num1\"`\n-\tOperator string `json:\"operator\"`\n-\tNum2     int    `json:\"num2\"`\n+\tOperator string `json:\"Operator\"`\n+\tNum2     int    `json:\"Num2\"`\n }\n \n /*\n 2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n"
                },
                {
                    "date": 1689926501558,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -49,9 +49,9 @@\n 2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n */\n \n type calculator struct {\n-\thistory []mathRequest\n+\thistory []MathRequest\n }\n \n func (c calculator) add(num1 int, num2 int) int {\n \top := mathRequest{num1, \"add\", num2}\n"
                },
                {
                    "date": 1689926515800,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,195 @@\n+/*\n+Json allows us to serialize our data to use somewhere else\n+Serialization is also how we can 'save' our work to be used later - think saving in games and then reloading it so you dont have to start from the start\n+\n+In this exercise we will take CalculatorA from the last exercise with the add, mult, divide, and sub functions and add some new functionality to it\n+\n+You might have noticed that Calculators also have some semblance of history of the operations performed - so that is what we will add\n+\n+1. Create a mathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the Calculator. So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n+\n+2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n+\n+3. create an encodeHistory function this will loop over all the mathRequests in the history slice inside the CalculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax\n+\n+so something like this\n+\n+json.Marshal is how you convert a struct into a []byte - and then you can convert []byte into string\n+func (c Calculator) encodeHistory() []string {\n+    for _, mr := range c.history {\n+    }\n+}\n+4. create a decodeHistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the Calculator slice . At the start of this function clear out whatever was in the slice previously\n+\n+json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n+*/\n+\n+package main\n+\n+import (\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"os\"\n+)\n+\n+var prt = fmt.Println\n+\n+/*\n+1. Create a MathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the calculator.\n+So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n+*/\n+\n+type mathRequest struct {\n+\tNum1     int    `json:\"Num1\"`\n+\tOperator string `json:\"Operator\"`\n+\tNum2     int    `json:\"Num2\"`\n+}\n+\n+/*\n+2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n+*/\n+\n+type calculator struct {\n+\thistory []MathRequest\n+}\n+\n+func (c calculator) add(num1 int, num2 int) int {\n+\top := c.MathRequest{num1, \"add\", num2}\n+\tc.history = append(c.history, op)\n+\treturn num1 + num2\n+}\n+\n+func (c calculator) sub(num1 int, num2 int) int {\n+\top := MathRequest{num1, \"sub\", num2}\n+\tc.history = append(c.history, op)\n+\treturn num1 - num2\n+}\n+\n+func (c calculator) mult(num1 int, num2 int) int {\n+\top := mathRequest{num1, \"mult\", num2}\n+\tc.history = append(c.history, op)\n+\treturn num1 * num2\n+}\n+\n+func (c calculator) divide(num1 int, num2 int) int {\n+\tif num2 == 0 {\n+\t\tprt(\"impossible to divide by zero\")\n+\t\treturn 0\n+\t}\n+\top := mathRequest{num1, \"Div\", num2}\n+\tc.history = append(c.history, op)\n+\treturn num1 / num2\n+}\n+\n+/*\n+3. create an encodehistory function this will loop over all the mathRequests in the history slice inside the calculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax. So something like this:\n+func (c calculator) encodehistory() []string {\n+    for _, mr := range c.history {\n+    }\n+}\n+*/\n+\n+func check(e error) (ok bool) {\n+\tif e != nil {\n+\t\tfmt.Printf(\"Error: %s\", e.Error())\n+\t\treturn false\n+\t}\n+\treturn true\n+}\n+\n+func (c calculator) encodeHistory() (eh []byte) {\n+\tprt(c.history)\n+\teh, err := json.Marshal(c.history)\n+\tif !check(err) {\n+\t\treturn nil\n+\t}\n+\treturn eh\n+}\n+\n+func (c calculator) saveToFile(eh []byte, fn string) {\n+\tf, err := os.Create(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\tn2, err := f.Write(eh) // I should check if the file already exists but...\n+\tif !check(err) {\n+\t\tf.Close()\n+\t}\n+\tprt(n2, \"bytes written successfully\")\n+\terr = f.Close()\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\tf2, err := os.ReadFile(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\tprt(\"this is \", fn, \" file: \", string(f2))\n+}\n+\n+/*\n+4. create a decodehistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the calculator slice . At the start of this function clear out whatever was in the slice previously\n+json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n+*/\n+\n+func (c calculator) decodeHistory(fn string) (f []byte) {\n+\tf, err := os.ReadFile(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\t// var data []interface{}\n+\t// err = json.Unmarshal(f, &data)\n+\tmr := make([]mathRequest, 10)\n+\terr = json.Unmarshal(f, &mr)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\treturn f\n+}\n+\n+func (c calculator) addToHistory(fn string) {\n+\tmr := make([]mathRequest, 10)\n+\tf, err := os.ReadFile(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\terr = json.Unmarshal(f, &mr)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\n+\tc.history = nil\n+\t// for _, mRequest := range mr {\n+\t// \tc.history = append(c.history, mathRequest(mRequest))\n+\t// }\n+\tfor _, mRequest := range mr {\n+\t\tc.history = append(c.history, mathRequest(mRequest))\n+\t}\n+\tprt(\"this is the last history:\", c.printHistory())\n+}\n+\n+// ancillary function\n+func (c calculator) printHistory() (history []string) {\n+\tfor _, v := range c.history {\n+\t\thistory = append(history, fmt.Sprintf(\"%+v\", v))\n+\t}\n+\treturn history\n+}\n+\n+func main() {\n+\tcalculator := calculator{}\n+\tprt(\"calculation with calculator:\")\n+\tprt(\"5 + 3 =\", calculator.add(5, 3))      // 8\n+\tprt(\"5 - 9 =\", calculator.sub(5, 9))      // -4\n+\tprt(\"22 * 33 =\", calculator.mult(22, 33)) // 726\n+\tprt(\"4 / 0 =\", calculator.divide(4, 0))   // impossible to divide by zero\n+\tprt(\"12 / 6 =\", calculator.divide(12, 6)) // 2\n+\tprt()\n+\t_ = calculator.encodeHistory()\n+\tcalculator.saveToFile(calculator.encodeHistory(), \"test.json\")\n+\thistory2 := []byte(`[{\"Num1\":6,\"Operator\":\"add\",\"Num2\":8},{\"Num1\":2,\"Operator\":\"sub\",\"Num2\":7},{\"Num1\":8,\"Operator\":\"mult\",\"Num2\":8},{\"Num1\":33,\"Operator\":\"Div\",\"Num2\":11}]`)\n+\tcalculator.saveToFile(history2, \"test2.json\")\n+\tcalculator.decodeHistory(\"test2.json\")\n+\tcalculator.addToHistory(\"test2.json\")\n+\tcalculator.printHistory()\n+}\n"
                },
                {
                    "date": 1689926525502,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -53,9 +53,9 @@\n \thistory []MathRequest\n }\n \n func (c calculator) add(num1 int, num2 int) int {\n-\top := c..MathRequest{num1, \"add\", num2}\n+\top := c {num1, \"add\", num2}\n \tc.history = append(c.history, op)\n \treturn num1 + num2\n }\n \n"
                },
                {
                    "date": 1689926535320,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,195 @@\n+/*\n+Json allows us to serialize our data to use somewhere else\n+Serialization is also how we can 'save' our work to be used later - think saving in games and then reloading it so you dont have to start from the start\n+\n+In this exercise we will take CalculatorA from the last exercise with the add, mult, divide, and sub functions and add some new functionality to it\n+\n+You might have noticed that Calculators also have some semblance of history of the operations performed - so that is what we will add\n+\n+1. Create a mathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the Calculator. So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n+\n+2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n+\n+3. create an encodeHistory function this will loop over all the mathRequests in the history slice inside the CalculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax\n+\n+so something like this\n+\n+json.Marshal is how you convert a struct into a []byte - and then you can convert []byte into string\n+func (c Calculator) encodeHistory() []string {\n+    for _, mr := range c.history {\n+    }\n+}\n+4. create a decodeHistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the Calculator slice . At the start of this function clear out whatever was in the slice previously\n+\n+json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n+*/\n+\n+package main\n+\n+import (\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"os\"\n+)\n+\n+var prt = fmt.Println\n+\n+/*\n+1. Create a MathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the calculator.\n+So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n+*/\n+\n+type mathRequest struct {\n+\tNum1     int    `json:\"Num1\"`\n+\tOperator string `json:\"Operator\"`\n+\tNum2     int    `json:\"Num2\"`\n+}\n+\n+/*\n+2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n+*/\n+\n+type calculator struct {\n+\thistory []MathRequest\n+}\n+\n+func (c calculator) add(num1 int, num2 int) int {\n+\top := c.M {num1, \"add\", num2}\n+\tc.history = append(c.history, op)\n+\treturn num1 + num2\n+}\n+\n+func (c calculator) sub(num1 int, num2 int) int {\n+\top := MathRequest{num1, \"sub\", num2}\n+\tc.history = append(c.history, op)\n+\treturn num1 - num2\n+}\n+\n+func (c calculator) mult(num1 int, num2 int) int {\n+\top := mathRequest{num1, \"mult\", num2}\n+\tc.history = append(c.history, op)\n+\treturn num1 * num2\n+}\n+\n+func (c calculator) divide(num1 int, num2 int) int {\n+\tif num2 == 0 {\n+\t\tprt(\"impossible to divide by zero\")\n+\t\treturn 0\n+\t}\n+\top := mathRequest{num1, \"Div\", num2}\n+\tc.history = append(c.history, op)\n+\treturn num1 / num2\n+}\n+\n+/*\n+3. create an encodehistory function this will loop over all the mathRequests in the history slice inside the calculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax. So something like this:\n+func (c calculator) encodehistory() []string {\n+    for _, mr := range c.history {\n+    }\n+}\n+*/\n+\n+func check(e error) (ok bool) {\n+\tif e != nil {\n+\t\tfmt.Printf(\"Error: %s\", e.Error())\n+\t\treturn false\n+\t}\n+\treturn true\n+}\n+\n+func (c calculator) encodeHistory() (eh []byte) {\n+\tprt(c.history)\n+\teh, err := json.Marshal(c.history)\n+\tif !check(err) {\n+\t\treturn nil\n+\t}\n+\treturn eh\n+}\n+\n+func (c calculator) saveToFile(eh []byte, fn string) {\n+\tf, err := os.Create(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\tn2, err := f.Write(eh) // I should check if the file already exists but...\n+\tif !check(err) {\n+\t\tf.Close()\n+\t}\n+\tprt(n2, \"bytes written successfully\")\n+\terr = f.Close()\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\tf2, err := os.ReadFile(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\tprt(\"this is \", fn, \" file: \", string(f2))\n+}\n+\n+/*\n+4. create a decodehistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the calculator slice . At the start of this function clear out whatever was in the slice previously\n+json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n+*/\n+\n+func (c calculator) decodeHistory(fn string) (f []byte) {\n+\tf, err := os.ReadFile(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\t// var data []interface{}\n+\t// err = json.Unmarshal(f, &data)\n+\tmr := make([]mathRequest, 10)\n+\terr = json.Unmarshal(f, &mr)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\treturn f\n+}\n+\n+func (c calculator) addToHistory(fn string) {\n+\tmr := make([]mathRequest, 10)\n+\tf, err := os.ReadFile(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\terr = json.Unmarshal(f, &mr)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\n+\tc.history = nil\n+\t// for _, mRequest := range mr {\n+\t// \tc.history = append(c.history, mathRequest(mRequest))\n+\t// }\n+\tfor _, mRequest := range mr {\n+\t\tc.history = append(c.history, mathRequest(mRequest))\n+\t}\n+\tprt(\"this is the last history:\", c.printHistory())\n+}\n+\n+// ancillary function\n+func (c calculator) printHistory() (history []string) {\n+\tfor _, v := range c.history {\n+\t\thistory = append(history, fmt.Sprintf(\"%+v\", v))\n+\t}\n+\treturn history\n+}\n+\n+func main() {\n+\tcalculator := calculator{}\n+\tprt(\"calculation with calculator:\")\n+\tprt(\"5 + 3 =\", calculator.add(5, 3))      // 8\n+\tprt(\"5 - 9 =\", calculator.sub(5, 9))      // -4\n+\tprt(\"22 * 33 =\", calculator.mult(22, 33)) // 726\n+\tprt(\"4 / 0 =\", calculator.divide(4, 0))   // impossible to divide by zero\n+\tprt(\"12 / 6 =\", calculator.divide(12, 6)) // 2\n+\tprt()\n+\t_ = calculator.encodeHistory()\n+\tcalculator.saveToFile(calculator.encodeHistory(), \"test.json\")\n+\thistory2 := []byte(`[{\"Num1\":6,\"Operator\":\"add\",\"Num2\":8},{\"Num1\":2,\"Operator\":\"sub\",\"Num2\":7},{\"Num1\":8,\"Operator\":\"mult\",\"Num2\":8},{\"Num1\":33,\"Operator\":\"Div\",\"Num2\":11}]`)\n+\tcalculator.saveToFile(history2, \"test2.json\")\n+\tcalculator.decodeHistory(\"test2.json\")\n+\tcalculator.addToHistory(\"test2.json\")\n+\tcalculator.printHistory()\n+}\n"
                }
            ],
            "date": 1689924302833,
            "name": "Commit-0",
            "content": "/*\nJson allows us to serialize our data to use somewhere else\nSerialization is also how we can 'save' our work to be used later - think saving in games and then reloading it so you dont have to start from the start\n\nIn this exercise we will take CalculatorA from the last exercise with the add, mult, divide, and sub functions and add some new functionality to it\n\nYou might have noticed that Calculators also have some semblance of history of the operations performed - so that is what we will add\n\n1. Create a MathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the Calculator. So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n\n2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n\n3. create an encodeHistory function this will loop over all the mathRequests in the history slice inside the CalculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax\n\nso something like this\n\njson.Marshal is how you convert a struct into a []byte - and then you can convert []byte into string\nfunc (c Calculator) encodeHistory() []string {\n    for _, mr := range c.history {\n    }\n}\n4. create a decodeHistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the Calculator slice . At the start of this function clear out whatever was in the slice previously\n\njson.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n*/\n\npackage main\n\n\n\nimport (\n\tc \"exercises/json/calculator\"\n\t\"fmt\"\n)\n\nvar prt = fmt.Println\nvar calc c.Calculator\n\nfunc main() {\n\tprt(\"calculation with Calculator:\")\n\tprt(\"5 + 3 =\", calc.Add(5, 3))      // 8\n\tprt(\"5 - 9 =\", calc.Sub(5, 9))      // -4\n\tprt(\"22 * 33 =\", calc.Mult(22, 33)) // 726\n\tprt(\"4 / 0 =\", calc.Divide(4, 0))   // impossible to divide by zero\n\tprt(\"12 / 6 =\", calc.Divide(12, 6)) // 2\n\tprt()\n\t_ = calc.EncodeHistory()\n\tcalc.SaveToFile(calc.EncodeHistory(), \"test.json\")\n\t// opCalc.DecodeHistory()\n\tHistory2 := []byte(`[{\"Num1\":6,\"Operator\":\"Add\",\"Num2\":8},{\"Num1\":2,\"Operator\":\"Sub\",\"Num2\":7},{\"Num1\":8,\"Operator\":\"Mult\",\"Num2\":8},{\"Num1\":33,\"Operator\":\"Div\",\"Num2\":11}]`)\n\tcalc.SaveToFile(History2, \"test2.json\")\n\tcalc.DecodeHistory(\"test2.json\")\n\tcalc.AddToHistory(\"test2.json\")\n\tcalc.PrintHistory()\n}\n"
        }
    ]
}