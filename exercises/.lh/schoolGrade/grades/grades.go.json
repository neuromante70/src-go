{
    "sourceFile": "schoolGrade/grades/grades.go",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 58,
            "patches": [
                {
                    "date": 1689837624233,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1689837646666,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1 @@\n+package\n\\ No newline at end of file\n"
                },
                {
                    "date": 1689837663667,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,1 +1,8 @@\n-package\n\\ No newline at end of file\n+package grades\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"strconv\"\n+)\n+\n"
                },
                {
                    "date": 1689837682716,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -5,4 +5,230 @@\n \t\"fmt\"\n \t\"strconv\"\n )\n \n+var prt = fmt.Println\n+\n+// 1. Create a student that will have an id and name as the fields - id is int and name is string\n+type student struct {\n+\tid   int\n+\tname string\n+}\n+\n+// Hint: You will have 2 maps in this exercise: 1st map\n+var Students = map[int]student{}\n+\n+func (s student) studentExist(idStd int) (student, bool) {\n+\tstudent, ok := Students[idStd]\n+\treturn student, ok\n+}\n+\n+func (s student) addStudent(std student) bool {\n+\t_, exist := s.studentExist(std.id)\n+\tif exist {\n+\t\tfmt.Println(\"The student\", std.name, \"is already present in db\")\n+\t\treturn false\n+\t}\n+\tStudents[std.id] = std\n+\tfmt.Println(\"The student\", std.name, \"wasn't present in db and now is correctly inserted\")\n+\treturn true\n+}\n+\n+func (s student) findStudent(idStd int) (student, error) {\n+\tstd, exists := s.studentExist(idStd)\n+\tif exists {\n+\t\treturn std, nil\n+\t}\n+\treturn student{}, errors.New(\"the ID student \" + strconv.Itoa(idStd) + \" is not in the database\")\n+}\n+\n+// 3. Delete student by ID\n+func (s student) deleteStudent(idStd int) {\n+\t_, ok := s.studentExist(idStd)\n+\tif ok {\n+\t\tdelete(Students, idStd)\n+\t\tfmt.Println(\"student\", idStd, \"correctly deleted\")\n+\t\treturn\n+\t}\n+\tfmt.Println(\"student non present, cannot delete it\")\n+}\n+\n+// 2. Create constants for subjects such as english, math, science and history\n+type subject int\n+\n+const (\n+\tenglish     subject = iota // 0\n+\tmathematics                // 1\n+\tscience                    // 2\n+\thistory                    // 3\n+)\n+\n+func returnSbj(idSub int) string {\n+\tswitch idSub {\n+\tcase 0:\n+\t\treturn \"english\"\n+\tcase 1:\n+\t\treturn \"math\"\n+\tcase 2:\n+\t\treturn \"science\"\n+\tcase 3:\n+\t\treturn \"history\"\n+\tdefault:\n+\t\treturn \"not found\"\n+\t}\n+}\n+\n+// 3. Create a grade struct that will hold a subject name string and an integer score denoting the 'marks'\n+type exam struct {\n+\tid      int // exam number\n+\tidStd   int // student id\n+\tsubject int // exam subject\n+\tgrade   int // exam grade\n+}\n+\n+// Hint: You will have 2 maps in this exercise: 2nd map\n+var Exams = map[int]exam{} // [int] is the exam number\n+\n+// A student can have grades for multiple subjects - so it is a one to many relation - grades will be kept in a list\n+type grade int\n+\n+// Here I decided to use the six-point system adopted by Phillips Academy at Andover.\n+const (\n+\tFailure              grade = iota // 0\n+\tLowFailure                        // 1\n+\tLowPassButCertifying              // 2\n+\tSatisfactory                      // 3\n+\tGood                              // 4\n+\tSuperiorHonor                     // 5\n+\tOutstandingHighHonor              // 6\n+)\n+\n+func returnGrade(idGrade int) string {\n+\tswitch idGrade {\n+\tcase 0:\n+\t\treturn \"Failure\"\n+\tcase 1:\n+\t\treturn \"Low Failure\"\n+\tcase 2:\n+\t\treturn \"Low Pass, but certifying\"\n+\tcase 3:\n+\t\treturn \"Satisfactory\"\n+\tcase 4:\n+\t\treturn \"Good\"\n+\tcase 5:\n+\t\treturn \"Superior (Honor)\"\n+\tcase 6:\n+\t\treturn \"Outstanding (High Honor)\"\n+\tdefault:\n+\t\treturn \"not found\"\n+\t}\n+}\n+\n+// 2. Get the average score across all subjects for a student id\n+func (s student) avgGrade() (avg int, err error) {\n+\tvar sum int\n+\tk := 0\n+\tfor _, v := range Exams {\n+\t\tif v.idStd == s.id {\n+\t\t\tsum += v.grade\n+\t\t\tk++\n+\t\t}\n+\t}\n+\tif k == 0 {\n+\t\treturn 0, errors.New(\"exams found for this student\")\n+\t}\n+\tavg = sum / k\n+\treturn avg, nil\n+}\n+\n+// 3. Get average score for a particular subject for a student id\n+func (s student) avgGradeBySbj(sbj int) (avg int, err error) {\n+\tvar sum int\n+\tk := 0\n+\tfor _, v := range Exams {\n+\t\tif v.idStd == s.id && v.subject == sbj {\n+\t\t\tsum += v.grade\n+\t\t\tk++\n+\t\t}\n+\t}\n+\tif k == 0 {\n+\t\treturn 0, errors.New(\"exams not found for this matter\")\n+\t}\n+\tavg = sum / k\n+\treturn avg, nil\n+}\n+\n+// 4. Get the subject with the lowest score for a student id\n+func (s student) lowGradeBySbj(sbj int) (low int, err error) {\n+\tlow = 0\n+\tfor _, v := range Exams {\n+\t\tif v.idStd == s.id && v.subject == sbj {\n+\t\t\tif low == 0 {\n+\t\t\t\tlow = v.grade\n+\t\t\t}\n+\t\t\tif v.grade < low {\n+\t\t\t\tlow = v.grade\n+\t\t\t}\n+\t\t}\n+\t}\n+\tif low == 0 {\n+\t\treturn 0, errors.New(\"exams not found for this student\")\n+\t}\n+\treturn low, nil\n+}\n+\n+// 5. Get the subject with the highest score for a student id\n+func (s student) highGradeBySbj(sbj int) (high int, err error) {\n+\thigh = 0\n+\tfor _, v := range Exams {\n+\t\tif v.idStd == s.id && v.subject == sbj {\n+\t\t\tif high == 0 {\n+\t\t\t\thigh = v.grade\n+\t\t\t}\n+\t\t\tif v.grade > high {\n+\t\t\t\thigh = v.grade\n+\t\t\t}\n+\t\t}\n+\t}\n+\tif high == 0 {\n+\t\treturn 0, errors.New(\"exams not found for this student\")\n+\t}\n+\treturn high, nil\n+}\n+\n+// 6. Get all grades for a student id\n+func (s student) allGrade() (result []int, err error) {\n+\tfor _, v := range Exams {\n+\t\tif v.idStd == s.id {\n+\t\t\tresult = append(result, v.grade)\n+\t\t}\n+\t}\n+\tif result == nil {\n+\t\treturn nil, errors.New(\"exams not found for this student\")\n+\t}\n+\treturn result, nil\n+}\n+\n+// extended print Exams\n+func (e exam) extPrint() {\n+\tprt(\"id exam:\", e.id)\n+\tprt(\"student name:\", Students[e.idStd].name)\n+\tprt(\"subject:\", returnSbj(e.subject))\n+\tprt(\"grade:\", returnGrade(e.grade))\n+}\n+\n+// print average grades\n+// func prtAvg(avg int, err error) {\n+// \tif err != nil {\n+// \t\tprt(err)\n+// \t\treturn\n+// \t}\n+// \tprt(avg)\n+// }\n+\n+func prtAvg(avg interface{}, err error) { // I know, it's bad\n+\tif err != nil {\n+\t\tprt(err)\n+\t\treturn\n+\t}\n+\tprt(avg)\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1689837721578,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,9 +8,9 @@\n \n var prt = fmt.Println\n \n // 1. Create a student that will have an id and name as the fields - id is int and name is string\n-type student struct {\n+type Student struct {\n \tid   int\n \tname string\n }\n \n"
                },
                {
                    "date": 1689837729336,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,9 +8,9 @@\n \n var prt = fmt.Println\n \n // 1. Create a student that will have an id and name as the fields - id is int and name is string\n-type Student struct {\n+type tudent struct {\n \tid   int\n \tname string\n }\n \n"
                },
                {
                    "date": 1689837747076,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -8,9 +8,9 @@\n \n var prt = fmt.Println\n \n // 1. Create a student that will have an id and name as the fields - id is int and name is string\n-type tudent struct {\n+type Student struct {\n \tid   int\n \tname string\n }\n \n"
                },
                {
                    "date": 1689837753497,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,9 +14,9 @@\n \tname string\n }\n \n // Hint: You will have 2 maps in this exercise: 1st map\n-var Students = map[int]student{}\n+var Students = map[int]Student{}\n \n func (s student) studentExist(idStd int) (student, bool) {\n \tstudent, ok := Students[idStd]\n \treturn student, ok\n"
                },
                {
                    "date": 1689837758663,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,9 +16,9 @@\n \n // Hint: You will have 2 maps in this exercise: 1st map\n var Students = map[int]Student{}\n \n-func (s student) studentExist(idStd int) (student, bool) {\n+func (s Student) StudentExist(idStd int) (student, bool) {\n \tstudent, ok := Students[idStd]\n \treturn student, ok\n }\n \n"
                },
                {
                    "date": 1689837789634,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,234 @@\n+package grades\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"strconv\"\n+)\n+\n+var prt = fmt.Println\n+\n+// 1. Create a student that will have an id and name as the fields - id is int and name is string\n+type Student struct {\n+\tid   int\n+\tname string\n+}\n+\n+// Hint: You will have 2 maps in this exercise: 1st map\n+var Students = map[int]Student{}\n+\n+func (s Student) StudentExist(idStd int) (Student, bool) {\n+\tStudent, ok := Students[idStd]\n+\treturn Student, ok\n+}\n+\n+func (s student) addStudent(std student) bool {\n+\t_, exist := s.studentExist(std.id)\n+\tif exist {\n+\t\tfmt.Println(\"The student\", std.name, \"is already present in db\")\n+\t\treturn false\n+\t}\n+\tStudents[std.id] = std\n+\tfmt.Println(\"The student\", std.name, \"wasn't present in db and now is correctly inserted\")\n+\treturn true\n+}\n+\n+func (s student) findStudent(idStd int) (student, error) {\n+\tstd, exists := s.studentExist(idStd)\n+\tif exists {\n+\t\treturn std, nil\n+\t}\n+\treturn student{}, errors.New(\"the ID student \" + strconv.Itoa(idStd) + \" is not in the database\")\n+}\n+\n+// 3. Delete student by ID\n+func (s student) deleteStudent(idStd int) {\n+\t_, ok := s.studentExist(idStd)\n+\tif ok {\n+\t\tdelete(Students, idStd)\n+\t\tfmt.Println(\"student\", idStd, \"correctly deleted\")\n+\t\treturn\n+\t}\n+\tfmt.Println(\"student non present, cannot delete it\")\n+}\n+\n+// 2. Create constants for subjects such as english, math, science and history\n+type subject int\n+\n+const (\n+\tenglish     subject = iota // 0\n+\tmathematics                // 1\n+\tscience                    // 2\n+\thistory                    // 3\n+)\n+\n+func returnSbj(idSub int) string {\n+\tswitch idSub {\n+\tcase 0:\n+\t\treturn \"english\"\n+\tcase 1:\n+\t\treturn \"math\"\n+\tcase 2:\n+\t\treturn \"science\"\n+\tcase 3:\n+\t\treturn \"history\"\n+\tdefault:\n+\t\treturn \"not found\"\n+\t}\n+}\n+\n+// 3. Create a grade struct that will hold a subject name string and an integer score denoting the 'marks'\n+type exam struct {\n+\tid      int // exam number\n+\tidStd   int // student id\n+\tsubject int // exam subject\n+\tgrade   int // exam grade\n+}\n+\n+// Hint: You will have 2 maps in this exercise: 2nd map\n+var Exams = map[int]exam{} // [int] is the exam number\n+\n+// A student can have grades for multiple subjects - so it is a one to many relation - grades will be kept in a list\n+type grade int\n+\n+// Here I decided to use the six-point system adopted by Phillips Academy at Andover.\n+const (\n+\tFailure              grade = iota // 0\n+\tLowFailure                        // 1\n+\tLowPassButCertifying              // 2\n+\tSatisfactory                      // 3\n+\tGood                              // 4\n+\tSuperiorHonor                     // 5\n+\tOutstandingHighHonor              // 6\n+)\n+\n+func returnGrade(idGrade int) string {\n+\tswitch idGrade {\n+\tcase 0:\n+\t\treturn \"Failure\"\n+\tcase 1:\n+\t\treturn \"Low Failure\"\n+\tcase 2:\n+\t\treturn \"Low Pass, but certifying\"\n+\tcase 3:\n+\t\treturn \"Satisfactory\"\n+\tcase 4:\n+\t\treturn \"Good\"\n+\tcase 5:\n+\t\treturn \"Superior (Honor)\"\n+\tcase 6:\n+\t\treturn \"Outstanding (High Honor)\"\n+\tdefault:\n+\t\treturn \"not found\"\n+\t}\n+}\n+\n+// 2. Get the average score across all subjects for a student id\n+func (s student) avgGrade() (avg int, err error) {\n+\tvar sum int\n+\tk := 0\n+\tfor _, v := range Exams {\n+\t\tif v.idStd == s.id {\n+\t\t\tsum += v.grade\n+\t\t\tk++\n+\t\t}\n+\t}\n+\tif k == 0 {\n+\t\treturn 0, errors.New(\"exams found for this student\")\n+\t}\n+\tavg = sum / k\n+\treturn avg, nil\n+}\n+\n+// 3. Get average score for a particular subject for a student id\n+func (s student) avgGradeBySbj(sbj int) (avg int, err error) {\n+\tvar sum int\n+\tk := 0\n+\tfor _, v := range Exams {\n+\t\tif v.idStd == s.id && v.subject == sbj {\n+\t\t\tsum += v.grade\n+\t\t\tk++\n+\t\t}\n+\t}\n+\tif k == 0 {\n+\t\treturn 0, errors.New(\"exams not found for this matter\")\n+\t}\n+\tavg = sum / k\n+\treturn avg, nil\n+}\n+\n+// 4. Get the subject with the lowest score for a student id\n+func (s student) lowGradeBySbj(sbj int) (low int, err error) {\n+\tlow = 0\n+\tfor _, v := range Exams {\n+\t\tif v.idStd == s.id && v.subject == sbj {\n+\t\t\tif low == 0 {\n+\t\t\t\tlow = v.grade\n+\t\t\t}\n+\t\t\tif v.grade < low {\n+\t\t\t\tlow = v.grade\n+\t\t\t}\n+\t\t}\n+\t}\n+\tif low == 0 {\n+\t\treturn 0, errors.New(\"exams not found for this student\")\n+\t}\n+\treturn low, nil\n+}\n+\n+// 5. Get the subject with the highest score for a student id\n+func (s student) highGradeBySbj(sbj int) (high int, err error) {\n+\thigh = 0\n+\tfor _, v := range Exams {\n+\t\tif v.idStd == s.id && v.subject == sbj {\n+\t\t\tif high == 0 {\n+\t\t\t\thigh = v.grade\n+\t\t\t}\n+\t\t\tif v.grade > high {\n+\t\t\t\thigh = v.grade\n+\t\t\t}\n+\t\t}\n+\t}\n+\tif high == 0 {\n+\t\treturn 0, errors.New(\"exams not found for this student\")\n+\t}\n+\treturn high, nil\n+}\n+\n+// 6. Get all grades for a student id\n+func (s student) allGrade() (result []int, err error) {\n+\tfor _, v := range Exams {\n+\t\tif v.idStd == s.id {\n+\t\t\tresult = append(result, v.grade)\n+\t\t}\n+\t}\n+\tif result == nil {\n+\t\treturn nil, errors.New(\"exams not found for this student\")\n+\t}\n+\treturn result, nil\n+}\n+\n+// extended print Exams\n+func (e exam) extPrint() {\n+\tprt(\"id exam:\", e.id)\n+\tprt(\"student name:\", Students[e.idStd].name)\n+\tprt(\"subject:\", returnSbj(e.subject))\n+\tprt(\"grade:\", returnGrade(e.grade))\n+}\n+\n+// print average grades\n+// func prtAvg(avg int, err error) {\n+// \tif err != nil {\n+// \t\tprt(err)\n+// \t\treturn\n+// \t}\n+// \tprt(avg)\n+// }\n+\n+func prtAvg(avg interface{}, err error) { // I know, it's bad\n+\tif err != nil {\n+\t\tprt(err)\n+\t\treturn\n+\t}\n+\tprt(avg)\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1689837799334,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -21,9 +21,9 @@\n \tStudent, ok := Students[idStd]\n \treturn Student, ok\n }\n \n-func (s student) addStudent(std student) bool {\n+func (s Student) addStudent(std Student) bool {\n \t_, exist := s.studentExist(std.id)\n \tif exist {\n \t\tfmt.Println(\"The student\", std.name, \"is already present in db\")\n \t\treturn false\n@@ -230,239 +230,5 @@\n \t\tprt(err)\n \t\treturn\n \t}\n \tprt(avg)\n-}\n-package grades\n-\n-import (\n-\t\"errors\"\n-\t\"fmt\"\n-\t\"strconv\"\n-)\n-\n-var prt = fmt.Println\n-\n-// 1. Create a student that will have an id and name as the fields - id is int and name is string\n-type Student struct {\n-\tid   int\n-\tname string\n-}\n-\n-// Hint: You will have 2 maps in this exercise: 1st map\n-var Students = map[int]Student{}\n-\n-func (s Student) StudentExist(idStd int) (student, bool) {\n-\tstudent, ok := Students[idStd]\n-\treturn student, ok\n-}\n-\n-func (s student) addStudent(std student) bool {\n-\t_, exist := s.studentExist(std.id)\n-\tif exist {\n-\t\tfmt.Println(\"The student\", std.name, \"is already present in db\")\n-\t\treturn false\n-\t}\n-\tStudents[std.id] = std\n-\tfmt.Println(\"The student\", std.name, \"wasn't present in db and now is correctly inserted\")\n-\treturn true\n-}\n-\n-func (s student) findStudent(idStd int) (student, error) {\n-\tstd, exists := s.studentExist(idStd)\n-\tif exists {\n-\t\treturn std, nil\n-\t}\n-\treturn student{}, errors.New(\"the ID student \" + strconv.Itoa(idStd) + \" is not in the database\")\n-}\n-\n-// 3. Delete student by ID\n-func (s student) deleteStudent(idStd int) {\n-\t_, ok := s.studentExist(idStd)\n-\tif ok {\n-\t\tdelete(Students, idStd)\n-\t\tfmt.Println(\"student\", idStd, \"correctly deleted\")\n-\t\treturn\n-\t}\n-\tfmt.Println(\"student non present, cannot delete it\")\n-}\n-\n-// 2. Create constants for subjects such as english, math, science and history\n-type subject int\n-\n-const (\n-\tenglish     subject = iota // 0\n-\tmathematics                // 1\n-\tscience                    // 2\n-\thistory                    // 3\n-)\n-\n-func returnSbj(idSub int) string {\n-\tswitch idSub {\n-\tcase 0:\n-\t\treturn \"english\"\n-\tcase 1:\n-\t\treturn \"math\"\n-\tcase 2:\n-\t\treturn \"science\"\n-\tcase 3:\n-\t\treturn \"history\"\n-\tdefault:\n-\t\treturn \"not found\"\n-\t}\n-}\n-\n-// 3. Create a grade struct that will hold a subject name string and an integer score denoting the 'marks'\n-type exam struct {\n-\tid      int // exam number\n-\tidStd   int // student id\n-\tsubject int // exam subject\n-\tgrade   int // exam grade\n-}\n-\n-// Hint: You will have 2 maps in this exercise: 2nd map\n-var Exams = map[int]exam{} // [int] is the exam number\n-\n-// A student can have grades for multiple subjects - so it is a one to many relation - grades will be kept in a list\n-type grade int\n-\n-// Here I decided to use the six-point system adopted by Phillips Academy at Andover.\n-const (\n-\tFailure              grade = iota // 0\n-\tLowFailure                        // 1\n-\tLowPassButCertifying              // 2\n-\tSatisfactory                      // 3\n-\tGood                              // 4\n-\tSuperiorHonor                     // 5\n-\tOutstandingHighHonor              // 6\n-)\n-\n-func returnGrade(idGrade int) string {\n-\tswitch idGrade {\n-\tcase 0:\n-\t\treturn \"Failure\"\n-\tcase 1:\n-\t\treturn \"Low Failure\"\n-\tcase 2:\n-\t\treturn \"Low Pass, but certifying\"\n-\tcase 3:\n-\t\treturn \"Satisfactory\"\n-\tcase 4:\n-\t\treturn \"Good\"\n-\tcase 5:\n-\t\treturn \"Superior (Honor)\"\n-\tcase 6:\n-\t\treturn \"Outstanding (High Honor)\"\n-\tdefault:\n-\t\treturn \"not found\"\n-\t}\n-}\n-\n-// 2. Get the average score across all subjects for a student id\n-func (s student) avgGrade() (avg int, err error) {\n-\tvar sum int\n-\tk := 0\n-\tfor _, v := range Exams {\n-\t\tif v.idStd == s.id {\n-\t\t\tsum += v.grade\n-\t\t\tk++\n-\t\t}\n-\t}\n-\tif k == 0 {\n-\t\treturn 0, errors.New(\"exams found for this student\")\n-\t}\n-\tavg = sum / k\n-\treturn avg, nil\n-}\n-\n-// 3. Get average score for a particular subject for a student id\n-func (s student) avgGradeBySbj(sbj int) (avg int, err error) {\n-\tvar sum int\n-\tk := 0\n-\tfor _, v := range Exams {\n-\t\tif v.idStd == s.id && v.subject == sbj {\n-\t\t\tsum += v.grade\n-\t\t\tk++\n-\t\t}\n-\t}\n-\tif k == 0 {\n-\t\treturn 0, errors.New(\"exams not found for this matter\")\n-\t}\n-\tavg = sum / k\n-\treturn avg, nil\n-}\n-\n-// 4. Get the subject with the lowest score for a student id\n-func (s student) lowGradeBySbj(sbj int) (low int, err error) {\n-\tlow = 0\n-\tfor _, v := range Exams {\n-\t\tif v.idStd == s.id && v.subject == sbj {\n-\t\t\tif low == 0 {\n-\t\t\t\tlow = v.grade\n-\t\t\t}\n-\t\t\tif v.grade < low {\n-\t\t\t\tlow = v.grade\n-\t\t\t}\n-\t\t}\n-\t}\n-\tif low == 0 {\n-\t\treturn 0, errors.New(\"exams not found for this student\")\n-\t}\n-\treturn low, nil\n-}\n-\n-// 5. Get the subject with the highest score for a student id\n-func (s student) highGradeBySbj(sbj int) (high int, err error) {\n-\thigh = 0\n-\tfor _, v := range Exams {\n-\t\tif v.idStd == s.id && v.subject == sbj {\n-\t\t\tif high == 0 {\n-\t\t\t\thigh = v.grade\n-\t\t\t}\n-\t\t\tif v.grade > high {\n-\t\t\t\thigh = v.grade\n-\t\t\t}\n-\t\t}\n-\t}\n-\tif high == 0 {\n-\t\treturn 0, errors.New(\"exams not found for this student\")\n-\t}\n-\treturn high, nil\n-}\n-\n-// 6. Get all grades for a student id\n-func (s student) allGrade() (result []int, err error) {\n-\tfor _, v := range Exams {\n-\t\tif v.idStd == s.id {\n-\t\t\tresult = append(result, v.grade)\n-\t\t}\n-\t}\n-\tif result == nil {\n-\t\treturn nil, errors.New(\"exams not found for this student\")\n-\t}\n-\treturn result, nil\n-}\n-\n-// extended print Exams\n-func (e exam) extPrint() {\n-\tprt(\"id exam:\", e.id)\n-\tprt(\"student name:\", Students[e.idStd].name)\n-\tprt(\"subject:\", returnSbj(e.subject))\n-\tprt(\"grade:\", returnGrade(e.grade))\n-}\n-\n-// print average grades\n-// func prtAvg(avg int, err error) {\n-// \tif err != nil {\n-// \t\tprt(err)\n-// \t\treturn\n-// \t}\n-// \tprt(avg)\n-// }\n-\n-func prtAvg(avg interface{}, err error) { // I know, it's bad\n-\tif err != nil {\n-\t\tprt(err)\n-\t\treturn\n-\t}\n-\tprt(avg)\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1689837805934,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,9 +22,9 @@\n \treturn Student, ok\n }\n \n func (s Student) addStudent(std Student) bool {\n-\t_, exist := s.studentExist(std.id)\n+\t_, exist := s.StudentExist(std.id)\n \tif exist {\n \t\tfmt.Println(\"The student\", std.name, \"is already present in db\")\n \t\treturn false\n \t}\n"
                },
                {
                    "date": 1689837824888,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,9 +32,9 @@\n \tfmt.Println(\"The student\", std.name, \"wasn't present in db and now is correctly inserted\")\n \treturn true\n }\n \n-func (s student) findStudent(idStd int) (student, error) {\n+func (s Student) findStudent(idStd int) (student, error) {\n \tstd, exists := s.studentExist(idStd)\n \tif exists {\n \t\treturn std, nil\n \t}\n"
                },
                {
                    "date": 1689837837837,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,10 +32,10 @@\n \tfmt.Println(\"The student\", std.name, \"wasn't present in db and now is correctly inserted\")\n \treturn true\n }\n \n-func (s Student) findStudent(idStd int) (student, error) {\n-\tstd, exists := s.studentExist(idStd)\n+func (s Student) findStudent(idStd int) (Student, error) {\n+\tstd, exists := s.StudentExist(idStd)\n \tif exists {\n \t\treturn std, nil\n \t}\n \treturn student{}, errors.New(\"the ID student \" + strconv.Itoa(idStd) + \" is not in the database\")\n"
                },
                {
                    "date": 1689837847829,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -37,13 +37,13 @@\n \tstd, exists := s.StudentExist(idStd)\n \tif exists {\n \t\treturn std, nil\n \t}\n-\treturn student{}, errors.New(\"the ID student \" + strconv.Itoa(idStd) + \" is not in the database\")\n+\treturn Student{}, errors.New(\"the ID student \" + strconv.Itoa(idStd) + \" is not in the database\")\n }\n \n // 3. Delete student by ID\n-func (s student) deleteStudent(idStd int) {\n+func (s Student) deleteStudent(idStd int) {\n \t_, ok := s.studentExist(idStd)\n \tif ok {\n \t\tdelete(Students, idStd)\n \t\tfmt.Println(\"student\", idStd, \"correctly deleted\")\n"
                },
                {
                    "date": 1689837852868,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -42,9 +42,9 @@\n }\n \n // 3. Delete student by ID\n func (s Student) deleteStudent(idStd int) {\n-\t_, ok := s.studentExist(idStd)\n+\t_, ok := s.StudentExist(idStd)\n \tif ok {\n \t\tdelete(Students, idStd)\n \t\tfmt.Println(\"student\", idStd, \"correctly deleted\")\n \t\treturn\n"
                },
                {
                    "date": 1689837864484,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -122,9 +122,9 @@\n \t\treturn \"not found\"\n \t}\n }\n \n-// 2. Get the average score across all subjects for a student id\n+// 2. Get the average score across all subjects for a Student id\n func (s student) avgGrade() (avg int, err error) {\n \tvar sum int\n \tk := 0\n \tfor _, v := range Exams {\n"
                },
                {
                    "date": 1689837869790,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -122,10 +122,10 @@\n \t\treturn \"not found\"\n \t}\n }\n \n-// 2. Get the average score across all subjects for a Student id\n-func (s student) avgGrade() (avg int, err error) {\n+// 2. Get the average score across all subjects for a student id\n+func (s Student) avgGrade() (avg int, err error) {\n \tvar sum int\n \tk := 0\n \tfor _, v := range Exams {\n \t\tif v.idStd == s.id {\n"
                },
                {
                    "date": 1689837878787,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -140,9 +140,9 @@\n \treturn avg, nil\n }\n \n // 3. Get average score for a particular subject for a student id\n-func (s student) avgGradeBySbj(sbj int) (avg int, err error) {\n+func (s Student) avgGradeBySbj(sbj int) (avg int, err error) {\n \tvar sum int\n \tk := 0\n \tfor _, v := range Exams {\n \t\tif v.idStd == s.id && v.subject == sbj {\n"
                },
                {
                    "date": 1689837887782,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -156,9 +156,9 @@\n \tavg = sum / k\n \treturn avg, nil\n }\n \n-// 4. Get the subject with the lowest score for a student id\n+// 4. Get the subject with the lowest score for a Student id\n func (s student) lowGradeBySbj(sbj int) (low int, err error) {\n \tlow = 0\n \tfor _, v := range Exams {\n \t\tif v.idStd == s.id && v.subject == sbj {\n"
                },
                {
                    "date": 1689837896092,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -157,9 +157,9 @@\n \treturn avg, nil\n }\n \n // 4. Get the subject with the lowest score for a Student id\n-func (s student) lowGradeBySbj(sbj int) (low int, err error) {\n+func (s Student) lowGradeBySbj(sbj int) (low int, err error) {\n \tlow = 0\n \tfor _, v := range Exams {\n \t\tif v.idStd == s.id && v.subject == sbj {\n \t\t\tif low == 0 {\n@@ -175,10 +175,10 @@\n \t}\n \treturn low, nil\n }\n \n-// 5. Get the subject with the highest score for a student id\n-func (s student) highGradeBySbj(sbj int) (high int, err error) {\n+// 5. Get the subject with the highest score for a Student id\n+func (s Student) highGradeBySbj(sbj int) (high int, err error) {\n \thigh = 0\n \tfor _, v := range Exams {\n \t\tif v.idStd == s.id && v.subject == sbj {\n \t\t\tif high == 0 {\n"
                },
                {
                    "date": 1689837901889,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -194,17 +194,17 @@\n \t}\n \treturn high, nil\n }\n \n-// 6. Get all grades for a student id\n-func (s student) allGrade() (result []int, err error) {\n+// 6. Get all grades for a Student id\n+func (s Student) allGrade() (result []int, err error) {\n \tfor _, v := range Exams {\n \t\tif v.idStd == s.id {\n \t\t\tresult = append(result, v.grade)\n \t\t}\n \t}\n \tif result == nil {\n-\t\treturn nil, errors.New(\"exams not found for this student\")\n+\t\treturn nil, errors.New(\"exams not found for this Student\")\n \t}\n \treturn result, nil\n }\n \n"
                },
                {
                    "date": 1689837934181,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,9 +9,9 @@\n var prt = fmt.Println\n \n // 1. Create a student that will have an id and name as the fields - id is int and name is string\n type Student struct {\n-\tid   int\n+\tId   int\n \tname string\n }\n \n // Hint: You will have 2 maps in this exercise: 1st map\n@@ -202,9 +202,9 @@\n \t\t\tresult = append(result, v.grade)\n \t\t}\n \t}\n \tif result == nil {\n-\t\treturn nil, errors.New(\"exams not found for this Student\")\n+\t\treturn nil, errors.New(\"exams not found for this student\")\n \t}\n \treturn result, nil\n }\n \n"
                },
                {
                    "date": 1689837956339,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,9 +10,9 @@\n \n // 1. Create a student that will have an id and name as the fields - id is int and name is string\n type Student struct {\n \tId   int\n-\tname string\n+\tName string\n }\n \n // Hint: You will have 2 maps in this exercise: 1st map\n var Students = map[int]Student{}\n@@ -21,9 +21,9 @@\n \tStudent, ok := Students[idStd]\n \treturn Student, ok\n }\n \n-func (s Student) addStudent(std Student) bool {\n+func (s Student) AddStudent(std Student) bool {\n \t_, exist := s.StudentExist(std.id)\n \tif exist {\n \t\tfmt.Println(\"The student\", std.name, \"is already present in db\")\n \t\treturn false\n"
                },
                {
                    "date": 1689837963891,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -32,18 +32,18 @@\n \tfmt.Println(\"The student\", std.name, \"wasn't present in db and now is correctly inserted\")\n \treturn true\n }\n \n-func (s Student) findStudent(idStd int) (Student, error) {\n+func (s Student) FindStudent(idStd int) (Student, error) {\n \tstd, exists := s.StudentExist(idStd)\n \tif exists {\n \t\treturn std, nil\n \t}\n \treturn Student{}, errors.New(\"the ID student \" + strconv.Itoa(idStd) + \" is not in the database\")\n }\n \n // 3. Delete student by ID\n-func (s Student) deleteStudent(idStd int) {\n+func (s Student) DeleteStudent(idStd int) {\n \t_, ok := s.StudentExist(idStd)\n \tif ok {\n \t\tdelete(Students, idStd)\n \t\tfmt.Println(\"student\", idStd, \"correctly deleted\")\n"
                },
                {
                    "date": 1689837969844,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -61,9 +61,9 @@\n \tscience                    // 2\n \thistory                    // 3\n )\n \n-func returnSbj(idSub int) string {\n+func ReturnSbj(idSub int) string {\n \tswitch idSub {\n \tcase 0:\n \t\treturn \"english\"\n \tcase 1:\n"
                },
                {
                    "date": 1689837977414,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -77,17 +77,17 @@\n \t}\n }\n \n // 3. Create a grade struct that will hold a subject name string and an integer score denoting the 'marks'\n-type exam struct {\n+type Exam struct {\n \tid      int // exam number\n \tidStd   int // student id\n \tsubject int // exam subject\n \tgrade   int // exam grade\n }\n \n // Hint: You will have 2 maps in this exercise: 2nd map\n-var Exams = map[int]exam{} // [int] is the exam number\n+var Exams = map[int]Exam{} // [int] is the exam number\n \n // A student can have grades for multiple subjects - so it is a one to many relation - grades will be kept in a list\n type grade int\n \n"
                },
                {
                    "date": 1689837983374,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -88,9 +88,9 @@\n // Hint: You will have 2 maps in this exercise: 2nd map\n var Exams = map[int]Exam{} // [int] is the exam number\n \n // A student can have grades for multiple subjects - so it is a one to many relation - grades will be kept in a list\n-type grade int\n+type Grade int\n \n // Here I decided to use the six-point system adopted by Phillips Academy at Andover.\n const (\n \tFailure              grade = iota // 0\n"
                },
                {
                    "date": 1689837991979,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -92,18 +92,18 @@\n type Grade int\n \n // Here I decided to use the six-point system adopted by Phillips Academy at Andover.\n const (\n-\tFailure              grade = iota // 0\n+\tFailure              Grade = iota // 0\n \tLowFailure                        // 1\n \tLowPassButCertifying              // 2\n \tSatisfactory                      // 3\n \tGood                              // 4\n \tSuperiorHonor                     // 5\n \tOutstandingHighHonor              // 6\n )\n \n-func returnGrade(idGrade int) string {\n+func ReturnGrade(idGrade int) string {\n \tswitch idGrade {\n \tcase 0:\n \t\treturn \"Failure\"\n \tcase 1:\n"
                },
                {
                    "date": 1689837999148,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -123,9 +123,9 @@\n \t}\n }\n \n // 2. Get the average score across all subjects for a student id\n-func (s Student) avgGrade() (avg int, err error) {\n+func (s Student) AvgGrade() (avg int, err error) {\n \tvar sum int\n \tk := 0\n \tfor _, v := range Exams {\n \t\tif v.idStd == s.id {\n"
                },
                {
                    "date": 1689838008230,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -140,9 +140,9 @@\n \treturn avg, nil\n }\n \n // 3. Get average score for a particular subject for a student id\n-func (s Student) avgGradeBySbj(sbj int) (avg int, err error) {\n+func (s Student) AvgGradeBySbj(sbj int) (avg int, err error) {\n \tvar sum int\n \tk := 0\n \tfor _, v := range Exams {\n \t\tif v.idStd == s.id && v.subject == sbj {\n@@ -157,9 +157,9 @@\n \treturn avg, nil\n }\n \n // 4. Get the subject with the lowest score for a Student id\n-func (s Student) lowGradeBySbj(sbj int) (low int, err error) {\n+func (s Student) LowGradeBySbj(sbj int) (low int, err error) {\n \tlow = 0\n \tfor _, v := range Exams {\n \t\tif v.idStd == s.id && v.subject == sbj {\n \t\t\tif low == 0 {\n"
                },
                {
                    "date": 1689838017328,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -195,9 +195,9 @@\n \treturn high, nil\n }\n \n // 6. Get all grades for a Student id\n-func (s Student) allGrade() (result []int, err error) {\n+func (s Student) AllGrade() (result []int, err error) {\n \tfor _, v := range Exams {\n \t\tif v.idStd == s.id {\n \t\t\tresult = append(result, v.grade)\n \t\t}\n"
                },
                {
                    "date": 1689838024674,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,234 @@\n+package grades\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"strconv\"\n+)\n+\n+var prt = fmt.Println\n+\n+// 1. Create a student that will have an id and name as the fields - id is int and name is string\n+type Student struct {\n+\tId   int\n+\tName string\n+}\n+\n+// Hint: You will have 2 maps in this exercise: 1st map\n+var Students = map[int]Student{}\n+\n+func (s Student) StudentExist(idStd int) (Student, bool) {\n+\tStudent, ok := Students[idStd]\n+\treturn Student, ok\n+}\n+\n+func (s Student) AddStudent(std Student) bool {\n+\t_, exist := s.StudentExist(std.id)\n+\tif exist {\n+\t\tfmt.Println(\"The student\", std.name, \"is already present in db\")\n+\t\treturn false\n+\t}\n+\tStudents[std.id] = std\n+\tfmt.Println(\"The student\", std.name, \"wasn't present in db and now is correctly inserted\")\n+\treturn true\n+}\n+\n+func (s Student) FindStudent(idStd int) (Student, error) {\n+\tstd, exists := s.StudentExist(idStd)\n+\tif exists {\n+\t\treturn std, nil\n+\t}\n+\treturn Student{}, errors.New(\"the ID student \" + strconv.Itoa(idStd) + \" is not in the database\")\n+}\n+\n+// 3. Delete student by ID\n+func (s Student) DeleteStudent(idStd int) {\n+\t_, ok := s.StudentExist(idStd)\n+\tif ok {\n+\t\tdelete(Students, idStd)\n+\t\tfmt.Println(\"student\", idStd, \"correctly deleted\")\n+\t\treturn\n+\t}\n+\tfmt.Println(\"student non present, cannot delete it\")\n+}\n+\n+// 2. Create constants for subjects such as english, math, science and history\n+type subject int\n+\n+const (\n+\tenglish     subject = iota // 0\n+\tmathematics                // 1\n+\tscience                    // 2\n+\thistory                    // 3\n+)\n+\n+func ReturnSbj(idSub int) string {\n+\tswitch idSub {\n+\tcase 0:\n+\t\treturn \"english\"\n+\tcase 1:\n+\t\treturn \"math\"\n+\tcase 2:\n+\t\treturn \"science\"\n+\tcase 3:\n+\t\treturn \"history\"\n+\tdefault:\n+\t\treturn \"not found\"\n+\t}\n+}\n+\n+// 3. Create a grade struct that will hold a subject name string and an integer score denoting the 'marks'\n+type Exam struct {\n+\tid      int // exam number\n+\tidStd   int // student id\n+\tsubject int // exam subject\n+\tgrade   int // exam grade\n+}\n+\n+// Hint: You will have 2 maps in this exercise: 2nd map\n+var Exams = map[int]Exam{} // [int] is the exam number\n+\n+// A student can have grades for multiple subjects - so it is a one to many relation - grades will be kept in a list\n+type Grade int\n+\n+// Here I decided to use the six-point system adopted by Phillips Academy at Andover.\n+const (\n+\tFailure              Grade = iota // 0\n+\tLowFailure                        // 1\n+\tLowPassButCertifying              // 2\n+\tSatisfactory                      // 3\n+\tGood                              // 4\n+\tSuperiorHonor                     // 5\n+\tOutstandingHighHonor              // 6\n+)\n+\n+func ReturnGrade(idGrade int) string {\n+\tswitch idGrade {\n+\tcase 0:\n+\t\treturn \"Failure\"\n+\tcase 1:\n+\t\treturn \"Low Failure\"\n+\tcase 2:\n+\t\treturn \"Low Pass, but certifying\"\n+\tcase 3:\n+\t\treturn \"Satisfactory\"\n+\tcase 4:\n+\t\treturn \"Good\"\n+\tcase 5:\n+\t\treturn \"Superior (Honor)\"\n+\tcase 6:\n+\t\treturn \"Outstanding (High Honor)\"\n+\tdefault:\n+\t\treturn \"not found\"\n+\t}\n+}\n+\n+// 2. Get the average score across all subjects for a student id\n+func (s Student) AvgGrade() (avg int, err error) {\n+\tvar sum int\n+\tk := 0\n+\tfor _, v := range Exams {\n+\t\tif v.idStd == s.id {\n+\t\t\tsum += v.grade\n+\t\t\tk++\n+\t\t}\n+\t}\n+\tif k == 0 {\n+\t\treturn 0, errors.New(\"exams found for this student\")\n+\t}\n+\tavg = sum / k\n+\treturn avg, nil\n+}\n+\n+// 3. Get average score for a particular subject for a student id\n+func (s Student) AvgGradeBySbj(sbj int) (avg int, err error) {\n+\tvar sum int\n+\tk := 0\n+\tfor _, v := range Exams {\n+\t\tif v.idStd == s.id && v.subject == sbj {\n+\t\t\tsum += v.grade\n+\t\t\tk++\n+\t\t}\n+\t}\n+\tif k == 0 {\n+\t\treturn 0, errors.New(\"exams not found for this matter\")\n+\t}\n+\tavg = sum / k\n+\treturn avg, nil\n+}\n+\n+// 4. Get the subject with the lowest score for a Student id\n+func (s Student) LowGradeBySbj(sbj int) (low int, err error) {\n+\tlow = 0\n+\tfor _, v := range Exams {\n+\t\tif v.idStd == s.id && v.subject == sbj {\n+\t\t\tif low == 0 {\n+\t\t\t\tlow = v.grade\n+\t\t\t}\n+\t\t\tif v.grade < low {\n+\t\t\t\tlow = v.grade\n+\t\t\t}\n+\t\t}\n+\t}\n+\tif low == 0 {\n+\t\treturn 0, errors.New(\"exams not found for this student\")\n+\t}\n+\treturn low, nil\n+}\n+\n+// 5. Get the subject with the highest score for a Student id\n+func (s Student) HighGradeBySbj(sbj int) (high int, err error) {\n+\thigh = 0\n+\tfor _, v := range Exams {\n+\t\tif v.idStd == s.id && v.subject == sbj {\n+\t\t\tif high == 0 {\n+\t\t\t\thigh = v.grade\n+\t\t\t}\n+\t\t\tif v.grade > high {\n+\t\t\t\thigh = v.grade\n+\t\t\t}\n+\t\t}\n+\t}\n+\tif high == 0 {\n+\t\treturn 0, errors.New(\"exams not found for this student\")\n+\t}\n+\treturn high, nil\n+}\n+\n+// 6. Get all grades for a Student id\n+func (s Student) AllGrade() (result []int, err error) {\n+\tfor _, v := range Exams {\n+\t\tif v.idStd == s.id {\n+\t\t\tresult = append(result, v.grade)\n+\t\t}\n+\t}\n+\tif result == nil {\n+\t\treturn nil, errors.New(\"exams not found for this student\")\n+\t}\n+\treturn result, nil\n+}\n+\n+// extended print Exams\n+func (e Exam) ExtPrint() {\n+\tprt(\"id exam:\", e.id)\n+\tprt(\"student name:\", Students[e.idStd].name)\n+\tprt(\"subject:\", returnSbj(e.subject))\n+\tprt(\"grade:\", returnGrade(e.grade))\n+}\n+\n+// print average grades\n+// func prtAvg(avg int, err error) {\n+// \tif err != nil {\n+// \t\tprt(err)\n+// \t\treturn\n+// \t}\n+// \tprt(avg)\n+// }\n+\n+func prtAvg(avg interface{}, err error) { // I know, it's bad\n+\tif err != nil {\n+\t\tprt(err)\n+\t\treturn\n+\t}\n+\tprt(avg)\n+}\n\\ No newline at end of file\n"
                },
                {
                    "date": 1689838038944,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -28,9 +28,9 @@\n \t\tfmt.Println(\"The student\", std.name, \"is already present in db\")\n \t\treturn false\n \t}\n \tStudents[std.id] = std\n-\tfmt.Println(\"The student\", std.name, \"wasn't present in db and now is correctly inserted\")\n+\tfmt.Println(\"The student\", std.Name, \"wasn't present in db and now is correctly inserted\")\n \treturn true\n }\n \n func (s Student) FindStudent(idStd int) (Student, error) {\n@@ -224,245 +224,11 @@\n // \t}\n // \tprt(avg)\n // }\n \n-func prtAvg(avg interface{}, err error) { // I know, it's bad\n+func PrtAvg(avg interface{}, err error) { // I know, it's bad\n \tif err != nil {\n \t\tprt(err)\n \t\treturn\n \t}\n \tprt(avg)\n-}\n-package grades\n-\n-import (\n-\t\"errors\"\n-\t\"fmt\"\n-\t\"strconv\"\n-)\n-\n-var prt = fmt.Println\n-\n-// 1. Create a student that will have an id and name as the fields - id is int and name is string\n-type Student struct {\n-\tId   int\n-\tName string\n-}\n-\n-// Hint: You will have 2 maps in this exercise: 1st map\n-var Students = map[int]Student{}\n-\n-func (s Student) StudentExist(idStd int) (Student, bool) {\n-\tStudent, ok := Students[idStd]\n-\treturn Student, ok\n-}\n-\n-func (s Student) AddStudent(std Student) bool {\n-\t_, exist := s.StudentExist(std.id)\n-\tif exist {\n-\t\tfmt.Println(\"The student\", std.name, \"is already present in db\")\n-\t\treturn false\n-\t}\n-\tStudents[std.id] = std\n-\tfmt.Println(\"The student\", std.name, \"wasn't present in db and now is correctly inserted\")\n-\treturn true\n-}\n-\n-func (s Student) FindStudent(idStd int) (Student, error) {\n-\tstd, exists := s.StudentExist(idStd)\n-\tif exists {\n-\t\treturn std, nil\n-\t}\n-\treturn Student{}, errors.New(\"the ID student \" + strconv.Itoa(idStd) + \" is not in the database\")\n-}\n-\n-// 3. Delete student by ID\n-func (s Student) DeleteStudent(idStd int) {\n-\t_, ok := s.StudentExist(idStd)\n-\tif ok {\n-\t\tdelete(Students, idStd)\n-\t\tfmt.Println(\"student\", idStd, \"correctly deleted\")\n-\t\treturn\n-\t}\n-\tfmt.Println(\"student non present, cannot delete it\")\n-}\n-\n-// 2. Create constants for subjects such as english, math, science and history\n-type subject int\n-\n-const (\n-\tenglish     subject = iota // 0\n-\tmathematics                // 1\n-\tscience                    // 2\n-\thistory                    // 3\n-)\n-\n-func ReturnSbj(idSub int) string {\n-\tswitch idSub {\n-\tcase 0:\n-\t\treturn \"english\"\n-\tcase 1:\n-\t\treturn \"math\"\n-\tcase 2:\n-\t\treturn \"science\"\n-\tcase 3:\n-\t\treturn \"history\"\n-\tdefault:\n-\t\treturn \"not found\"\n-\t}\n-}\n-\n-// 3. Create a grade struct that will hold a subject name string and an integer score denoting the 'marks'\n-type Exam struct {\n-\tid      int // exam number\n-\tidStd   int // student id\n-\tsubject int // exam subject\n-\tgrade   int // exam grade\n-}\n-\n-// Hint: You will have 2 maps in this exercise: 2nd map\n-var Exams = map[int]Exam{} // [int] is the exam number\n-\n-// A student can have grades for multiple subjects - so it is a one to many relation - grades will be kept in a list\n-type Grade int\n-\n-// Here I decided to use the six-point system adopted by Phillips Academy at Andover.\n-const (\n-\tFailure              Grade = iota // 0\n-\tLowFailure                        // 1\n-\tLowPassButCertifying              // 2\n-\tSatisfactory                      // 3\n-\tGood                              // 4\n-\tSuperiorHonor                     // 5\n-\tOutstandingHighHonor              // 6\n-)\n-\n-func ReturnGrade(idGrade int) string {\n-\tswitch idGrade {\n-\tcase 0:\n-\t\treturn \"Failure\"\n-\tcase 1:\n-\t\treturn \"Low Failure\"\n-\tcase 2:\n-\t\treturn \"Low Pass, but certifying\"\n-\tcase 3:\n-\t\treturn \"Satisfactory\"\n-\tcase 4:\n-\t\treturn \"Good\"\n-\tcase 5:\n-\t\treturn \"Superior (Honor)\"\n-\tcase 6:\n-\t\treturn \"Outstanding (High Honor)\"\n-\tdefault:\n-\t\treturn \"not found\"\n-\t}\n-}\n-\n-// 2. Get the average score across all subjects for a student id\n-func (s Student) AvgGrade() (avg int, err error) {\n-\tvar sum int\n-\tk := 0\n-\tfor _, v := range Exams {\n-\t\tif v.idStd == s.id {\n-\t\t\tsum += v.grade\n-\t\t\tk++\n-\t\t}\n-\t}\n-\tif k == 0 {\n-\t\treturn 0, errors.New(\"exams found for this student\")\n-\t}\n-\tavg = sum / k\n-\treturn avg, nil\n-}\n-\n-// 3. Get average score for a particular subject for a student id\n-func (s Student) AvgGradeBySbj(sbj int) (avg int, err error) {\n-\tvar sum int\n-\tk := 0\n-\tfor _, v := range Exams {\n-\t\tif v.idStd == s.id && v.subject == sbj {\n-\t\t\tsum += v.grade\n-\t\t\tk++\n-\t\t}\n-\t}\n-\tif k == 0 {\n-\t\treturn 0, errors.New(\"exams not found for this matter\")\n-\t}\n-\tavg = sum / k\n-\treturn avg, nil\n-}\n-\n-// 4. Get the subject with the lowest score for a Student id\n-func (s Student) LowGradeBySbj(sbj int) (low int, err error) {\n-\tlow = 0\n-\tfor _, v := range Exams {\n-\t\tif v.idStd == s.id && v.subject == sbj {\n-\t\t\tif low == 0 {\n-\t\t\t\tlow = v.grade\n-\t\t\t}\n-\t\t\tif v.grade < low {\n-\t\t\t\tlow = v.grade\n-\t\t\t}\n-\t\t}\n-\t}\n-\tif low == 0 {\n-\t\treturn 0, errors.New(\"exams not found for this student\")\n-\t}\n-\treturn low, nil\n-}\n-\n-// 5. Get the subject with the highest score for a Student id\n-func (s Student) highGradeBySbj(sbj int) (high int, err error) {\n-\thigh = 0\n-\tfor _, v := range Exams {\n-\t\tif v.idStd == s.id && v.subject == sbj {\n-\t\t\tif high == 0 {\n-\t\t\t\thigh = v.grade\n-\t\t\t}\n-\t\t\tif v.grade > high {\n-\t\t\t\thigh = v.grade\n-\t\t\t}\n-\t\t}\n-\t}\n-\tif high == 0 {\n-\t\treturn 0, errors.New(\"exams not found for this student\")\n-\t}\n-\treturn high, nil\n-}\n-\n-// 6. Get all grades for a Student id\n-func (s Student) AllGrade() (result []int, err error) {\n-\tfor _, v := range Exams {\n-\t\tif v.idStd == s.id {\n-\t\t\tresult = append(result, v.grade)\n-\t\t}\n-\t}\n-\tif result == nil {\n-\t\treturn nil, errors.New(\"exams not found for this student\")\n-\t}\n-\treturn result, nil\n-}\n-\n-// extended print Exams\n-func (e exam) extPrint() {\n-\tprt(\"id exam:\", e.id)\n-\tprt(\"student name:\", Students[e.idStd].name)\n-\tprt(\"subject:\", returnSbj(e.subject))\n-\tprt(\"grade:\", returnGrade(e.grade))\n-}\n-\n-// print average grades\n-// func prtAvg(avg int, err error) {\n-// \tif err != nil {\n-// \t\tprt(err)\n-// \t\treturn\n-// \t}\n-// \tprt(avg)\n-// }\n-\n-func prtAvg(avg interface{}, err error) { // I know, it's bad\n-\tif err != nil {\n-\t\tprt(err)\n-\t\treturn\n-\t}\n-\tprt(avg)\n }\n\\ No newline at end of file\n"
                },
                {
                    "date": 1689838046327,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -22,11 +22,11 @@\n \treturn Student, ok\n }\n \n func (s Student) AddStudent(std Student) bool {\n-\t_, exist := s.StudentExist(std.id)\n+\t_, exist := s.StudentExist(std.Id)\n \tif exist {\n-\t\tfmt.Println(\"The student\", std.name, \"is already present in db\")\n+\t\tfmt.Println(\"The student\", std.Name, \"is already present in db\")\n \t\treturn false\n \t}\n \tStudents[std.id] = std\n \tfmt.Println(\"The student\", std.Name, \"wasn't present in db and now is correctly inserted\")\n"
                },
                {
                    "date": 1689838055599,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -127,9 +127,9 @@\n func (s Student) AvgGrade() (avg int, err error) {\n \tvar sum int\n \tk := 0\n \tfor _, v := range Exams {\n-\t\tif v.idStd == s.id {\n+\t\tif v.idStd == s.Id {\n \t\t\tsum += v.grade\n \t\t\tk++\n \t\t}\n \t}\n"
                },
                {
                    "date": 1689838061035,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -144,9 +144,9 @@\n func (s Student) AvgGradeBySbj(sbj int) (avg int, err error) {\n \tvar sum int\n \tk := 0\n \tfor _, v := range Exams {\n-\t\tif v.idStd == s.id && v.subject == sbj {\n+\t\tif v.idStd == s.Id && v.subject == sbj {\n \t\t\tsum += v.grade\n \t\t\tk++\n \t\t}\n \t}\n"
                },
                {
                    "date": 1689838068663,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -160,9 +160,9 @@\n // 4. Get the subject with the lowest score for a Student id\n func (s Student) LowGradeBySbj(sbj int) (low int, err error) {\n \tlow = 0\n \tfor _, v := range Exams {\n-\t\tif v.idStd == s.id && v.subject == sbj {\n+\t\tif v.idStd == s.Id && v.subject == sbj {\n \t\t\tif low == 0 {\n \t\t\t\tlow = v.grade\n \t\t\t}\n \t\t\tif v.grade < low {\n@@ -179,9 +179,9 @@\n // 5. Get the subject with the highest score for a Student id\n func (s Student) HighGradeBySbj(sbj int) (high int, err error) {\n \thigh = 0\n \tfor _, v := range Exams {\n-\t\tif v.idStd == s.id && v.subject == sbj {\n+\t\tif v.idStd == s.Id && v.subject == sbj {\n \t\t\tif high == 0 {\n \t\t\t\thigh = v.grade\n \t\t\t}\n \t\t\tif v.grade > high {\n"
                },
                {
                    "date": 1689838076943,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -197,9 +197,9 @@\n \n // 6. Get all grades for a Student id\n func (s Student) AllGrade() (result []int, err error) {\n \tfor _, v := range Exams {\n-\t\tif v.idStd == s.id {\n+\t\tif v.idStd == s.Id {\n \t\t\tresult = append(result, v.grade)\n \t\t}\n \t}\n \tif result == nil {\n@@ -210,9 +210,9 @@\n \n // extended print Exams\n func (e Exam) ExtPrint() {\n \tprt(\"id exam:\", e.id)\n-\tprt(\"student name:\", Students[e.idStd].name)\n+\tprt(\"student name:\", Students[e.idStd].Name)\n \tprt(\"subject:\", returnSbj(e.subject))\n \tprt(\"grade:\", returnGrade(e.grade))\n }\n \n"
                },
                {
                    "date": 1689838083148,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -211,10 +211,10 @@\n // extended print Exams\n func (e Exam) ExtPrint() {\n \tprt(\"id exam:\", e.id)\n \tprt(\"student name:\", Students[e.idStd].Name)\n-\tprt(\"subject:\", returnSbj(e.subject))\n-\tprt(\"grade:\", returnGrade(e.grade))\n+\tprt(\"subject:\", ReturnSbj(e.subject))\n+\tprt(\"grade:\", ReturnGrade(e.grade))\n }\n \n // print average grades\n // func prtAvg(avg int, err error) {\n"
                },
                {
                    "date": 1689838359561,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -78,9 +78,9 @@\n }\n \n // 3. Create a grade struct that will hold a subject name string and an integer score denoting the 'marks'\n type Exam struct {\n-\tid      int // exam number\n+\tId      int // exam number\n \tidStd   int // student id\n \tsubject int // exam subject\n \tgrade   int // exam grade\n }\n@@ -230,5 +230,5 @@\n \t\tprt(err)\n \t\treturn\n \t}\n \tprt(avg)\n-}\n\\ No newline at end of file\n+}\n"
                },
                {
                    "date": 1689838365437,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -79,11 +79,11 @@\n \n // 3. Create a grade struct that will hold a subject name string and an integer score denoting the 'marks'\n type Exam struct {\n \tId      int // exam number\n-\tidStd   int // student id\n-\tsubject int // exam subject\n-\tgrade   int // exam grade\n+\tIdStd   int // student id\n+\tSubject int // exam subject\n+\tGrade   int // exam grade\n }\n \n // Hint: You will have 2 maps in this exercise: 2nd map\n var Exams = map[int]Exam{} // [int] is the exam number\n"
                },
                {
                    "date": 1689838378674,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -27,9 +27,9 @@\n \tif exist {\n \t\tfmt.Println(\"The student\", std.Name, \"is already present in db\")\n \t\treturn false\n \t}\n-\tStudents[std.id] = std\n+\tStudents[std.Id] = std\n \tfmt.Println(\"The student\", std.Name, \"wasn't present in db and now is correctly inserted\")\n \treturn true\n }\n \n"
                },
                {
                    "date": 1689838389595,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -127,9 +127,9 @@\n func (s Student) AvgGrade() (avg int, err error) {\n \tvar sum int\n \tk := 0\n \tfor _, v := range Exams {\n-\t\tif v.idStd == s.Id {\n+\t\tif v.IdStd == s.Id {\n \t\t\tsum += v.grade\n \t\t\tk++\n \t\t}\n \t}\n"
                },
                {
                    "date": 1689838397163,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -128,9 +128,9 @@\n \tvar sum int\n \tk := 0\n \tfor _, v := range Exams {\n \t\tif v.IdStd == s.Id {\n-\t\t\tsum += v.grade\n+\t\t\tsum += v.Grade\n \t\t\tk++\n \t\t}\n \t}\n \tif k == 0 {\n@@ -144,9 +144,9 @@\n func (s Student) AvgGradeBySbj(sbj int) (avg int, err error) {\n \tvar sum int\n \tk := 0\n \tfor _, v := range Exams {\n-\t\tif v.idStd == s.Id && v.subject == sbj {\n+\t\tif v.IdStd == s.Id && v.subject == sbj {\n \t\t\tsum += v.grade\n \t\t\tk++\n \t\t}\n \t}\n"
                },
                {
                    "date": 1689838403239,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -144,10 +144,10 @@\n func (s Student) AvgGradeBySbj(sbj int) (avg int, err error) {\n \tvar sum int\n \tk := 0\n \tfor _, v := range Exams {\n-\t\tif v.IdStd == s.Id && v.subject == sbj {\n-\t\t\tsum += v.grade\n+\t\tif v.IdStd == s.Id && v.Subject == sbj {\n+\t\t\tsum += v.Grade\n \t\t\tk++\n \t\t}\n \t}\n \tif k == 0 {\n"
                },
                {
                    "date": 1689838410405,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -160,9 +160,9 @@\n // 4. Get the subject with the lowest score for a Student id\n func (s Student) LowGradeBySbj(sbj int) (low int, err error) {\n \tlow = 0\n \tfor _, v := range Exams {\n-\t\tif v.idStd == s.Id && v.subject == sbj {\n+\t\tif v.IdStd == s.Id && v.Subject == sbj {\n \t\t\tif low == 0 {\n \t\t\t\tlow = v.grade\n \t\t\t}\n \t\t\tif v.grade < low {\n"
                },
                {
                    "date": 1689838416177,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -162,11 +162,11 @@\n \tlow = 0\n \tfor _, v := range Exams {\n \t\tif v.IdStd == s.Id && v.Subject == sbj {\n \t\t\tif low == 0 {\n-\t\t\t\tlow = v.grade\n+\t\t\t\tlow = v.Grade\n \t\t\t}\n-\t\t\tif v.grade < low {\n+\t\t\tif v.Grade < low {\n \t\t\t\tlow = v.grade\n \t\t\t}\n \t\t}\n \t}\n"
                },
                {
                    "date": 1689838428890,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -165,9 +165,9 @@\n \t\t\tif low == 0 {\n \t\t\t\tlow = v.Grade\n \t\t\t}\n \t\t\tif v.Grade < low {\n-\t\t\t\tlow = v.grade\n+\t\t\t\tlow = v.Grade\n \t\t\t}\n \t\t}\n \t}\n \tif low == 0 {\n@@ -179,9 +179,9 @@\n // 5. Get the subject with the highest score for a Student id\n func (s Student) HighGradeBySbj(sbj int) (high int, err error) {\n \thigh = 0\n \tfor _, v := range Exams {\n-\t\tif v.idStd == s.Id && v.subject == sbj {\n+\t\tif v.IdStd == s.Id && v.subject == sbj {\n \t\t\tif high == 0 {\n \t\t\t\thigh = v.grade\n \t\t\t}\n \t\t\tif v.grade > high {\n"
                },
                {
                    "date": 1689838435163,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,234 @@\n+package grades\n+\n+import (\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"strconv\"\n+)\n+\n+var prt = fmt.Println\n+\n+// 1. Create a student that will have an id and name as the fields - id is int and name is string\n+type Student struct {\n+\tId   int\n+\tName string\n+}\n+\n+// Hint: You will have 2 maps in this exercise: 1st map\n+var Students = map[int]Student{}\n+\n+func (s Student) StudentExist(idStd int) (Student, bool) {\n+\tStudent, ok := Students[idStd]\n+\treturn Student, ok\n+}\n+\n+func (s Student) AddStudent(std Student) bool {\n+\t_, exist := s.StudentExist(std.Id)\n+\tif exist {\n+\t\tfmt.Println(\"The student\", std.Name, \"is already present in db\")\n+\t\treturn false\n+\t}\n+\tStudents[std.Id] = std\n+\tfmt.Println(\"The student\", std.Name, \"wasn't present in db and now is correctly inserted\")\n+\treturn true\n+}\n+\n+func (s Student) FindStudent(idStd int) (Student, error) {\n+\tstd, exists := s.StudentExist(idStd)\n+\tif exists {\n+\t\treturn std, nil\n+\t}\n+\treturn Student{}, errors.New(\"the ID student \" + strconv.Itoa(idStd) + \" is not in the database\")\n+}\n+\n+// 3. Delete student by ID\n+func (s Student) DeleteStudent(idStd int) {\n+\t_, ok := s.StudentExist(idStd)\n+\tif ok {\n+\t\tdelete(Students, idStd)\n+\t\tfmt.Println(\"student\", idStd, \"correctly deleted\")\n+\t\treturn\n+\t}\n+\tfmt.Println(\"student non present, cannot delete it\")\n+}\n+\n+// 2. Create constants for subjects such as english, math, science and history\n+type subject int\n+\n+const (\n+\tenglish     subject = iota // 0\n+\tmathematics                // 1\n+\tscience                    // 2\n+\thistory                    // 3\n+)\n+\n+func ReturnSbj(idSub int) string {\n+\tswitch idSub {\n+\tcase 0:\n+\t\treturn \"english\"\n+\tcase 1:\n+\t\treturn \"math\"\n+\tcase 2:\n+\t\treturn \"science\"\n+\tcase 3:\n+\t\treturn \"history\"\n+\tdefault:\n+\t\treturn \"not found\"\n+\t}\n+}\n+\n+// 3. Create a grade struct that will hold a subject name string and an integer score denoting the 'marks'\n+type Exam struct {\n+\tId      int // exam number\n+\tIdStd   int // student id\n+\tSubject int // exam subject\n+\tGrade   int // exam grade\n+}\n+\n+// Hint: You will have 2 maps in this exercise: 2nd map\n+var Exams = map[int]Exam{} // [int] is the exam number\n+\n+// A student can have grades for multiple subjects - so it is a one to many relation - grades will be kept in a list\n+type Grade int\n+\n+// Here I decided to use the six-point system adopted by Phillips Academy at Andover.\n+const (\n+\tFailure              Grade = iota // 0\n+\tLowFailure                        // 1\n+\tLowPassButCertifying              // 2\n+\tSatisfactory                      // 3\n+\tGood                              // 4\n+\tSuperiorHonor                     // 5\n+\tOutstandingHighHonor              // 6\n+)\n+\n+func ReturnGrade(idGrade int) string {\n+\tswitch idGrade {\n+\tcase 0:\n+\t\treturn \"Failure\"\n+\tcase 1:\n+\t\treturn \"Low Failure\"\n+\tcase 2:\n+\t\treturn \"Low Pass, but certifying\"\n+\tcase 3:\n+\t\treturn \"Satisfactory\"\n+\tcase 4:\n+\t\treturn \"Good\"\n+\tcase 5:\n+\t\treturn \"Superior (Honor)\"\n+\tcase 6:\n+\t\treturn \"Outstanding (High Honor)\"\n+\tdefault:\n+\t\treturn \"not found\"\n+\t}\n+}\n+\n+// 2. Get the average score across all subjects for a student id\n+func (s Student) AvgGrade() (avg int, err error) {\n+\tvar sum int\n+\tk := 0\n+\tfor _, v := range Exams {\n+\t\tif v.IdStd == s.Id {\n+\t\t\tsum += v.Grade\n+\t\t\tk++\n+\t\t}\n+\t}\n+\tif k == 0 {\n+\t\treturn 0, errors.New(\"exams found for this student\")\n+\t}\n+\tavg = sum / k\n+\treturn avg, nil\n+}\n+\n+// 3. Get average score for a particular subject for a student id\n+func (s Student) AvgGradeBySbj(sbj int) (avg int, err error) {\n+\tvar sum int\n+\tk := 0\n+\tfor _, v := range Exams {\n+\t\tif v.IdStd == s.Id && v.Subject == sbj {\n+\t\t\tsum += v.Grade\n+\t\t\tk++\n+\t\t}\n+\t}\n+\tif k == 0 {\n+\t\treturn 0, errors.New(\"exams not found for this matter\")\n+\t}\n+\tavg = sum / k\n+\treturn avg, nil\n+}\n+\n+// 4. Get the subject with the lowest score for a Student id\n+func (s Student) LowGradeBySbj(sbj int) (low int, err error) {\n+\tlow = 0\n+\tfor _, v := range Exams {\n+\t\tif v.IdStd == s.Id && v.Subject == sbj {\n+\t\t\tif low == 0 {\n+\t\t\t\tlow = v.Grade\n+\t\t\t}\n+\t\t\tif v.Grade < low {\n+\t\t\t\tlow = v.Grade\n+\t\t\t}\n+\t\t}\n+\t}\n+\tif low == 0 {\n+\t\treturn 0, errors.New(\"exams not found for this student\")\n+\t}\n+\treturn low, nil\n+}\n+\n+// 5. Get the subject with the highest score for a Student id\n+func (s Student) HighGradeBySbj(sbj int) (high int, err error) {\n+\thigh = 0\n+\tfor _, v := range Exams {\n+\t\tif v.IdStd == s.Id && v.subject == sbj {\n+\t\t\tif high == 0 {\n+\t\t\t\thigh = v.grade\n+\t\t\t}\n+\t\t\tif v.grade > high {\n+\t\t\t\thigh = v.grade\n+\t\t\t}\n+\t\t}\n+\t}\n+\tif high == 0 {\n+\t\treturn 0, errors.New(\"exams not found for this student\")\n+\t}\n+\treturn high, nil\n+}\n+\n+// 6. Get all grades for a Student id\n+func (s Student) AllGrade() (result []int, err error) {\n+\tfor _, v := range Exams {\n+\t\tif v.IdStd == s.Id {\n+\t\t\tresult = append(result, v.grade)\n+\t\t}\n+\t}\n+\tif result == nil {\n+\t\treturn nil, errors.New(\"exams not found for this student\")\n+\t}\n+\treturn result, nil\n+}\n+\n+// extended print Exams\n+func (e Exam) ExtPrint() {\n+\tprt(\"id exam:\", e.id)\n+\tprt(\"student name:\", Students[e.IdStd].Name)\n+\tprt(\"subject:\", ReturnSbj(e.subject))\n+\tprt(\"grade:\", ReturnGrade(e.grade))\n+}\n+\n+// print average grades\n+// func prtAvg(avg int, err error) {\n+// \tif err != nil {\n+// \t\tprt(err)\n+// \t\treturn\n+// \t}\n+// \tprt(avg)\n+// }\n+\n+func PrtAvg(avg interface{}, err error) { // I know, it's bad\n+\tif err != nil {\n+\t\tprt(err)\n+\t\treturn\n+\t}\n+\tprt(avg)\n+}\n"
                },
                {
                    "date": 1689838442411,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -179,9 +179,9 @@\n // 5. Get the subject with the highest score for a Student id\n func (s Student) HighGradeBySbj(sbj int) (high int, err error) {\n \thigh = 0\n \tfor _, v := range Exams {\n-\t\tif v.IdStd == s.Id && v.subject == sbj {\n+\t\tif v.IdStd == s.Id && v.Subject == sbj {\n \t\t\tif high == 0 {\n \t\t\t\thigh = v.grade\n \t\t\t}\n \t\t\tif v.grade > high {\n@@ -231,238 +231,4 @@\n \t\treturn\n \t}\n \tprt(avg)\n }\n-package grades\n-\n-import (\n-\t\"errors\"\n-\t\"fmt\"\n-\t\"strconv\"\n-)\n-\n-var prt = fmt.Println\n-\n-// 1. Create a student that will have an id and name as the fields - id is int and name is string\n-type Student struct {\n-\tId   int\n-\tName string\n-}\n-\n-// Hint: You will have 2 maps in this exercise: 1st map\n-var Students = map[int]Student{}\n-\n-func (s Student) StudentExist(idStd int) (Student, bool) {\n-\tStudent, ok := Students[idStd]\n-\treturn Student, ok\n-}\n-\n-func (s Student) AddStudent(std Student) bool {\n-\t_, exist := s.StudentExist(std.Id)\n-\tif exist {\n-\t\tfmt.Println(\"The student\", std.Name, \"is already present in db\")\n-\t\treturn false\n-\t}\n-\tStudents[std.Id] = std\n-\tfmt.Println(\"The student\", std.Name, \"wasn't present in db and now is correctly inserted\")\n-\treturn true\n-}\n-\n-func (s Student) FindStudent(idStd int) (Student, error) {\n-\tstd, exists := s.StudentExist(idStd)\n-\tif exists {\n-\t\treturn std, nil\n-\t}\n-\treturn Student{}, errors.New(\"the ID student \" + strconv.Itoa(idStd) + \" is not in the database\")\n-}\n-\n-// 3. Delete student by ID\n-func (s Student) DeleteStudent(idStd int) {\n-\t_, ok := s.StudentExist(idStd)\n-\tif ok {\n-\t\tdelete(Students, idStd)\n-\t\tfmt.Println(\"student\", idStd, \"correctly deleted\")\n-\t\treturn\n-\t}\n-\tfmt.Println(\"student non present, cannot delete it\")\n-}\n-\n-// 2. Create constants for subjects such as english, math, science and history\n-type subject int\n-\n-const (\n-\tenglish     subject = iota // 0\n-\tmathematics                // 1\n-\tscience                    // 2\n-\thistory                    // 3\n-)\n-\n-func ReturnSbj(idSub int) string {\n-\tswitch idSub {\n-\tcase 0:\n-\t\treturn \"english\"\n-\tcase 1:\n-\t\treturn \"math\"\n-\tcase 2:\n-\t\treturn \"science\"\n-\tcase 3:\n-\t\treturn \"history\"\n-\tdefault:\n-\t\treturn \"not found\"\n-\t}\n-}\n-\n-// 3. Create a grade struct that will hold a subject name string and an integer score denoting the 'marks'\n-type Exam struct {\n-\tId      int // exam number\n-\tIdStd   int // student id\n-\tSubject int // exam subject\n-\tGrade   int // exam grade\n-}\n-\n-// Hint: You will have 2 maps in this exercise: 2nd map\n-var Exams = map[int]Exam{} // [int] is the exam number\n-\n-// A student can have grades for multiple subjects - so it is a one to many relation - grades will be kept in a list\n-type Grade int\n-\n-// Here I decided to use the six-point system adopted by Phillips Academy at Andover.\n-const (\n-\tFailure              Grade = iota // 0\n-\tLowFailure                        // 1\n-\tLowPassButCertifying              // 2\n-\tSatisfactory                      // 3\n-\tGood                              // 4\n-\tSuperiorHonor                     // 5\n-\tOutstandingHighHonor              // 6\n-)\n-\n-func ReturnGrade(idGrade int) string {\n-\tswitch idGrade {\n-\tcase 0:\n-\t\treturn \"Failure\"\n-\tcase 1:\n-\t\treturn \"Low Failure\"\n-\tcase 2:\n-\t\treturn \"Low Pass, but certifying\"\n-\tcase 3:\n-\t\treturn \"Satisfactory\"\n-\tcase 4:\n-\t\treturn \"Good\"\n-\tcase 5:\n-\t\treturn \"Superior (Honor)\"\n-\tcase 6:\n-\t\treturn \"Outstanding (High Honor)\"\n-\tdefault:\n-\t\treturn \"not found\"\n-\t}\n-}\n-\n-// 2. Get the average score across all subjects for a student id\n-func (s Student) AvgGrade() (avg int, err error) {\n-\tvar sum int\n-\tk := 0\n-\tfor _, v := range Exams {\n-\t\tif v.IdStd == s.Id {\n-\t\t\tsum += v.Grade\n-\t\t\tk++\n-\t\t}\n-\t}\n-\tif k == 0 {\n-\t\treturn 0, errors.New(\"exams found for this student\")\n-\t}\n-\tavg = sum / k\n-\treturn avg, nil\n-}\n-\n-// 3. Get average score for a particular subject for a student id\n-func (s Student) AvgGradeBySbj(sbj int) (avg int, err error) {\n-\tvar sum int\n-\tk := 0\n-\tfor _, v := range Exams {\n-\t\tif v.IdStd == s.Id && v.Subject == sbj {\n-\t\t\tsum += v.Grade\n-\t\t\tk++\n-\t\t}\n-\t}\n-\tif k == 0 {\n-\t\treturn 0, errors.New(\"exams not found for this matter\")\n-\t}\n-\tavg = sum / k\n-\treturn avg, nil\n-}\n-\n-// 4. Get the subject with the lowest score for a Student id\n-func (s Student) LowGradeBySbj(sbj int) (low int, err error) {\n-\tlow = 0\n-\tfor _, v := range Exams {\n-\t\tif v.IdStd == s.Id && v.Subject == sbj {\n-\t\t\tif low == 0 {\n-\t\t\t\tlow = v.Grade\n-\t\t\t}\n-\t\t\tif v.Grade < low {\n-\t\t\t\tlow = v.Grade\n-\t\t\t}\n-\t\t}\n-\t}\n-\tif low == 0 {\n-\t\treturn 0, errors.New(\"exams not found for this student\")\n-\t}\n-\treturn low, nil\n-}\n-\n-// 5. Get the subject with the highest score for a Student id\n-func (s Student) HighGradeBySbj(sbj int) (high int, err error) {\n-\thigh = 0\n-\tfor _, v := range Exams {\n-\t\tif v.IdStd == s.Id && v.subject == sbj {\n-\t\t\tif high == 0 {\n-\t\t\t\thigh = v.grade\n-\t\t\t}\n-\t\t\tif v.grade > high {\n-\t\t\t\thigh = v.grade\n-\t\t\t}\n-\t\t}\n-\t}\n-\tif high == 0 {\n-\t\treturn 0, errors.New(\"exams not found for this student\")\n-\t}\n-\treturn high, nil\n-}\n-\n-// 6. Get all grades for a Student id\n-func (s Student) AllGrade() (result []int, err error) {\n-\tfor _, v := range Exams {\n-\t\tif v.idStd == s.Id {\n-\t\t\tresult = append(result, v.grade)\n-\t\t}\n-\t}\n-\tif result == nil {\n-\t\treturn nil, errors.New(\"exams not found for this student\")\n-\t}\n-\treturn result, nil\n-}\n-\n-// extended print Exams\n-func (e Exam) ExtPrint() {\n-\tprt(\"id exam:\", e.id)\n-\tprt(\"student name:\", Students[e.idStd].Name)\n-\tprt(\"subject:\", ReturnSbj(e.subject))\n-\tprt(\"grade:\", ReturnGrade(e.grade))\n-}\n-\n-// print average grades\n-// func prtAvg(avg int, err error) {\n-// \tif err != nil {\n-// \t\tprt(err)\n-// \t\treturn\n-// \t}\n-// \tprt(avg)\n-// }\n-\n-func PrtAvg(avg interface{}, err error) { // I know, it's bad\n-\tif err != nil {\n-\t\tprt(err)\n-\t\treturn\n-\t}\n-\tprt(avg)\n-}\n"
                },
                {
                    "date": 1689838448387,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -211,9 +211,9 @@\n // extended print Exams\n func (e Exam) ExtPrint() {\n \tprt(\"id exam:\", e.id)\n \tprt(\"student name:\", Students[e.IdStd].Name)\n-\tprt(\"subject:\", ReturnSbj(e.subject))\n+\tprt(\"subject:\", ReturnSbj(e.Subject))\n \tprt(\"grade:\", ReturnGrade(e.grade))\n }\n \n // print average grades\n"
                },
                {
                    "date": 1689838454030,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -209,9 +209,9 @@\n }\n \n // extended print Exams\n func (e Exam) ExtPrint() {\n-\tprt(\"id exam:\", e.id)\n+\tprt(\"id exam:\", e.Id)\n \tprt(\"student name:\", Students[e.IdStd].Name)\n \tprt(\"subject:\", ReturnSbj(e.Subject))\n \tprt(\"grade:\", ReturnGrade(e.grade))\n }\n"
                },
                {
                    "date": 1689838459769,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -181,9 +181,9 @@\n \thigh = 0\n \tfor _, v := range Exams {\n \t\tif v.IdStd == s.Id && v.Subject == sbj {\n \t\t\tif high == 0 {\n-\t\t\t\thigh = v.grade\n+\t\t\t\thigh = v.Grade\n \t\t\t}\n \t\t\tif v.grade > high {\n \t\t\t\thigh = v.grade\n \t\t\t}\n"
                },
                {
                    "date": 1689838465365,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -183,10 +183,10 @@\n \t\tif v.IdStd == s.Id && v.Subject == sbj {\n \t\t\tif high == 0 {\n \t\t\t\thigh = v.Grade\n \t\t\t}\n-\t\t\tif v.grade > high {\n-\t\t\t\thigh = v.grade\n+\t\t\tif v.Grade > high {\n+\t\t\t\thigh = v.Grade\n \t\t\t}\n \t\t}\n \t}\n \tif high == 0 {\n@@ -198,9 +198,9 @@\n // 6. Get all grades for a Student id\n func (s Student) AllGrade() (result []int, err error) {\n \tfor _, v := range Exams {\n \t\tif v.IdStd == s.Id {\n-\t\t\tresult = append(result, v.grade)\n+\t\t\tresult = append(result, v.Grade)\n \t\t}\n \t}\n \tif result == nil {\n \t\treturn nil, errors.New(\"exams not found for this student\")\n@@ -212,9 +212,9 @@\n func (e Exam) ExtPrint() {\n \tprt(\"id exam:\", e.Id)\n \tprt(\"student name:\", Students[e.IdStd].Name)\n \tprt(\"subject:\", ReturnSbj(e.Subject))\n-\tprt(\"grade:\", ReturnGrade(e.grade))\n+\tprt(\"grade:\", ReturnGrade(e.Grade))\n }\n \n // print average grades\n // func prtAvg(avg int, err error) {\n"
                },
                {
                    "date": 1689838732381,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -55,9 +55,9 @@\n // 2. Create constants for subjects such as english, math, science and history\n type subject int\n \n const (\n-\tenglish     subject = iota // 0\n+\tEnglish     subject = iota // 0\n \tmathematics                // 1\n \tscience                    // 2\n \thistory                    // 3\n )\n"
                },
                {
                    "date": 1689838738761,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -56,11 +56,11 @@\n type subject int\n \n const (\n \tEnglish     subject = iota // 0\n-\tmathematics                // 1\n-\tscience                    // 2\n-\thistory                    // 3\n+\tMathematics                // 1\n+\tScience                    // 2\n+\tHistory                    // 3\n )\n \n func ReturnSbj(idSub int) string {\n \tswitch idSub {\n"
                },
                {
                    "date": 1689838748238,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -52,9 +52,9 @@\n \tfmt.Println(\"student non present, cannot delete it\")\n }\n \n // 2. Create constants for subjects such as english, math, science and history\n-type subject int\n+type Subject int\n \n const (\n \tEnglish     subject = iota // 0\n \tMathematics                // 1\n"
                },
                {
                    "date": 1689838763764,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -55,9 +55,9 @@\n // 2. Create constants for subjects such as english, math, science and history\n type Subject int\n \n const (\n-\tEnglish     subject = iota // 0\n+\tEnglish     Subject = iota // 0\n \tMathematics                // 1\n \tScience                    // 2\n \tHistory                    // 3\n )\n"
                }
            ],
            "date": 1689837624233,
            "name": "Commit-0",
            "content": ""
        }
    ]
}