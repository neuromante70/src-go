{
    "sourceFile": "json/calculator/calculator.go",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 10,
            "patches": [
                {
                    "date": 1689701174681,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1689701188309,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -28,10 +28,10 @@\n }\n \n var MyCalc Calculator\n \n-func (c Calculator) Add(num1 int, Num2 int) int {\n-\top := MathRequest{Num1, \"Add\", Num2}\n+func (c Calculator) Add(num1 int, num2 int) int {\n+\top := MathRequest{num1, \"Add\", Num2}\n \tMyCalc.History = append(MyCalc.History, op)\n \treturn Num1 + Num2\n }\n \n"
                },
                {
                    "date": 1689701195688,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,31 +31,31 @@\n \n func (c Calculator) Add(num1 int, num2 int) int {\n \top := MathRequest{num1, \"Add\", Num2}\n \tMyCalc.History = append(MyCalc.History, op)\n-\treturn Num1 + Num2\n+\treturn num1 + Num2\n }\n \n-func (c Calculator) Sub(Num1 int, Num2 int) int {\n-\top := MathRequest{Num1, \"Sub\", Num2}\n+func (c Calculator) Sub(num1 int, Num2 int) int {\n+\top := MathRequest{num1, \"Sub\", Num2}\n \tMyCalc.History = append(MyCalc.History, op)\n-\treturn Num1 - Num2\n+\treturn num1 - Num2\n }\n \n-func (c Calculator) Mult(Num1 int, Num2 int) int {\n-\top := MathRequest{Num1, \"Mult\", Num2}\n+func (c Calculator) Mult(num1 int, Num2 int) int {\n+\top := MathRequest{num1, \"Mult\", Num2}\n \tMyCalc.History = append(MyCalc.History, op)\n-\treturn Num1 * Num2\n+\treturn num1 * Num2\n }\n \n-func (c Calculator) Divide(Num1 int, Num2 int) int {\n+func (c Calculator) Divide(num1 int, Num2 int) int {\n \tif Num2 == 0 {\n \t\tprt(\"impossible to divide by zero\")\n \t\treturn 0\n \t} else {\n-\t\top := MathRequest{Num1, \"Div\", Num2}\n+\t\top := MathRequest{num1, \"Div\", Num2}\n \t\tMyCalc.History = append(MyCalc.History, op)\n-\t\treturn Num1 / Num2\n+\t\treturn num1 / Num2\n \t}\n }\n \n /*\n"
                },
                {
                    "date": 1689701203666,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -140,9 +140,9 @@\n \tif !check(err) {\n \t\treturn\n \t}\n \t// for i := 0; i < len(mr)-1; i++ {\n-\t// \tMyCalc.History[i].Num1 = mr[i].Num1\n+\t// \tMyCalc.History[i].num1 = mr[i].Num1\n \t// \tMyCalc.History[i].Operator = mr[i].Operator\n \t// \tMyCalc.History[i].Num2 = mr[i].Num2\n \t// }\n \tMyCalc.History = nil\n"
                },
                {
                    "date": 1689701226707,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -140,9 +140,9 @@\n \tif !check(err) {\n \t\treturn\n \t}\n \t// for i := 0; i < len(mr)-1; i++ {\n-\t// \tMyCalc.History[i].num1 = mr[i].Num1\n+\t// \tMyCalc.History[i].num1 = mr[i].num1\n \t// \tMyCalc.History[i].Operator = mr[i].Operator\n \t// \tMyCalc.History[i].Num2 = mr[i].Num2\n \t// }\n \tMyCalc.History = nil\n"
                },
                {
                    "date": 1689701242714,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -29,9 +29,9 @@\n \n var MyCalc Calculator\n \n func (c Calculator) Add(num1 int, num2 int) int {\n-\top := MathRequest{num1, \"Add\", Num2}\n+\top := MathRequest{num1, \"Add\", num2}\n \tMyCalc.History = append(MyCalc.History, op)\n \treturn num1 + Num2\n }\n \n"
                },
                {
                    "date": 1689701248885,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -31,25 +31,25 @@\n \n func (c Calculator) Add(num1 int, num2 int) int {\n \top := MathRequest{num1, \"Add\", num2}\n \tMyCalc.History = append(MyCalc.History, op)\n-\treturn num1 + Num2\n+\treturn num1 + num2\n }\n \n-func (c Calculator) Sub(num1 int, Num2 int) int {\n-\top := MathRequest{num1, \"Sub\", Num2}\n+func (c Calculator) Sub(num1 int, num2 int) int {\n+\top := MathRequest{num1, \"Sub\", num2}\n \tMyCalc.History = append(MyCalc.History, op)\n-\treturn num1 - Num2\n+\treturn num1 - num2\n }\n \n-func (c Calculator) Mult(num1 int, Num2 int) int {\n-\top := MathRequest{num1, \"Mult\", Num2}\n+func (c Calculator) Mult(num1 int, num2 int) int {\n+\top := MathRequest{num1, \"Mult\", num2}\n \tMyCalc.History = append(MyCalc.History, op)\n-\treturn num1 * Num2\n+\treturn num1 * num2\n }\n \n-func (c Calculator) Divide(num1 int, Num2 int) int {\n-\tif Num2 == 0 {\n+func (c Calculator) Divide(num1 int, num2 int) int {\n+\tif num2 == 0 {\n \t\tprt(\"impossible to divide by zero\")\n \t\treturn 0\n \t} else {\n \t\top := MathRequest{num1, \"Div\", Num2}\n"
                },
                {
                    "date": 1689701254353,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,11 +51,11 @@\n \tif num2 == 0 {\n \t\tprt(\"impossible to divide by zero\")\n \t\treturn 0\n \t} else {\n-\t\top := MathRequest{num1, \"Div\", Num2}\n+\t\top := MathRequest{num1, \"Div\", num2}\n \t\tMyCalc.History = append(MyCalc.History, op)\n-\t\treturn num1 / Num2\n+\t\treturn num1 / num2\n \t}\n }\n \n /*\n"
                },
                {
                    "date": 1689701302693,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -50,9 +50,9 @@\n func (c Calculator) Divide(num1 int, num2 int) int {\n \tif num2 == 0 {\n \t\tprt(\"impossible to divide by zero\")\n \t\treturn 0\n-\t} else {\n+\t}\n \t\top := MathRequest{num1, \"Div\", num2}\n \t\tMyCalc.History = append(MyCalc.History, op)\n \t\treturn num1 / num2\n \t}\n"
                },
                {
                    "date": 1689701308165,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,11 +51,11 @@\n \tif num2 == 0 {\n \t\tprt(\"impossible to divide by zero\")\n \t\treturn 0\n \t}\n-\t\top := MathRequest{num1, \"Div\", num2}\n-\t\tMyCalc.History = append(MyCalc.History, op)\n-\t\treturn num1 / num2\n+\top := MathRequest{num1, \"Div\", num2}\n+\tMyCalc.History = append(MyCalc.History, op)\n+\treturn num1 / num2\n }\n \n /*\n 3. create an encodeHistory function this will loop over all the mathRequests in the history slice inside the calculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax. So something like this:\n"
                },
                {
                    "date": 1689701469661,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,162 @@\n+package calc\n+\n+import (\n+\t\"encoding/json\"\n+\t\"fmt\"\n+\t\"os\"\n+)\n+\n+var prt = fmt.Println\n+\n+/*\n+1. Create a MathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the calculator.\n+So an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n+*/\n+\n+type MathRequest struct {\n+\tNum1     int    `json:\"Num1\"`\n+\tOperator string `json:\"Operator\"`\n+\tNum2     int    `json:\"Num2\"`\n+}\n+\n+/*\n+2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n+*/\n+\n+type Calculator struct {\n+\tHistory []MathRequest\n+}\n+\n+var MyCalc Calculator\n+\n+func (c Calculator) Add(num1 int, num2 int) int {\n+\top := MathRequest{num1, \"Add\", num2}\n+\tMyCalc.History = append(MyCalc.History, op)\n+\treturn num1 + num2\n+}\n+\n+func (c Calculator) Sub(num1 int, num2 int) int {\n+\top := MathRequest{num1, \"Sub\", num2}\n+\tMyCalc.History = append(MyCalc.History, op)\n+\treturn num1 - num2\n+}\n+\n+func (c Calculator) Mult(num1 int, num2 int) int {\n+\top := MathRequest{num1, \"Mult\", num2}\n+\tMyCalc.History = append(MyCalc.History, op)\n+\treturn num1 * num2\n+}\n+\n+func (c Calculator) Divide(num1 int, num2 int) int {\n+\tif num2 == 0 {\n+\t\tprt(\"impossible to divide by zero\")\n+\t\treturn 0\n+\t}\n+\top := MathRequest{num1, \"Div\", num2}\n+\tMyCalc.History = append(MyCalc.History, op)\n+\treturn num1 / num2\n+}\n+\n+/*\n+3. create an encodeHistory function this will loop over all the mathRequests in the history slice inside the calculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax. So something like this:\n+func (c calculator) encodeHistory() []string {\n+    for _, mr := range c.history {\n+    }\n+}\n+*/\n+\n+func check(e error) (ok bool) {\n+\tif e != nil {\n+\t\tfmt.Printf(\"Error: %s\", e.Error())\n+\t\treturn false\n+\t}\n+\treturn true\n+}\n+\n+func (c Calculator) EncodeHistory() (EH []byte) {\n+\tEH, err := json.Marshal(MyCalc.History)\n+\tif !check(err) {\n+\t\treturn nil\n+\t}\n+\t// prt(\"this is returned from json converter:\", string(j))\n+\treturn EH\n+}\n+\n+func (c Calculator) SaveToFile(EH []byte, fn string) {\n+\tf, err := os.Create(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\tn2, err := f.Write(EH) // I should check if the file already exists but...\n+\tif !check(err) {\n+\t\tf.Close()\n+\t}\n+\tprt(n2, \"bytes written successfully\")\n+\terr = f.Close()\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\tf2, err := os.ReadFile(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\tprt(\"this is \", fn, \" file: \", string(f2))\n+}\n+\n+/*\n+4. create a decodeHistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the calculator slice . At the start of this function clear out whatever was in the slice previously\n+\n+json.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n+*/\n+\n+// type MR []struct {\n+// \tNum1     int\n+// \tOperator string\n+// \tNum2     int\n+// }\n+\n+func (c Calculator) DecodeHistory(fn string) (f []byte) {\n+\tf, err := os.ReadFile(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\t// var data []interface{}\n+\t// err = json.Unmarshal(f, &data)\n+\tmr := make([]MathRequest, 10)\n+\terr = json.Unmarshal(f, &mr)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\treturn f\n+}\n+\n+func (c Calculator) AddToHistory(fn string) {\n+\tmr := MR{}\n+\tf, err := os.ReadFile(fn)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\terr = json.Unmarshal(f, &mr)\n+\tif !check(err) {\n+\t\treturn\n+\t}\n+\t// for i := 0; i < len(mr)-1; i++ {\n+\t// \tMyCalc.History[i].num1 = mr[i].num1\n+\t// \tMyCalc.History[i].Operator = mr[i].Operator\n+\t// \tMyCalc.History[i].Num2 = mr[i].Num2\n+\t// }\n+\tMyCalc.History = nil\n+\tfor i := 0; i < len(mr); i++ {\n+\t\top := MathRequest{mr[i].Num1, mr[i].Operator, mr[i].Num2}\n+\t\tMyCalc.History = append(MyCalc.History, op)\n+\t}\n+\tprt(\"this is the last history:\", c.PrintHistory())\n+}\n+\n+// ancillary function\n+func (c Calculator) PrintHistory() (history []string) {\n+\tfor _, v := range MyCalc.History {\n+\t\thistory = append(history, fmt.Sprintf(\"%+v\", v))\n+\t}\n+\treturn history\n+}\n"
                }
            ],
            "date": 1689701174681,
            "name": "Commit-0",
            "content": "package calc\n\nimport (\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n)\n\nvar prt = fmt.Println\n\n/*\n1. Create a MathRequest struct - this will have two integers and an operation string - this is how we will model all the add/mult/sub/divide requests that come into the calculator.\nSo an add function call will create a math request where the two ints are the two inputs and the operation is \"add\"\n*/\n\ntype MathRequest struct {\n\tNum1     int    `json:\"Num1\"`\n\tOperator string `json:\"Operator\"`\n\tNum2     int    `json:\"Num2\"`\n}\n\n/*\n2. In the CalculatorA struct create a slice of math requests named history - this is where we will append all math requests that are created in the different functions - so this will be our list of history\n*/\n\ntype Calculator struct {\n\tHistory []MathRequest\n}\n\nvar MyCalc Calculator\n\nfunc (c Calculator) Add(num1 int, Num2 int) int {\n\top := MathRequest{Num1, \"Add\", Num2}\n\tMyCalc.History = append(MyCalc.History, op)\n\treturn Num1 + Num2\n}\n\nfunc (c Calculator) Sub(Num1 int, Num2 int) int {\n\top := MathRequest{Num1, \"Sub\", Num2}\n\tMyCalc.History = append(MyCalc.History, op)\n\treturn Num1 - Num2\n}\n\nfunc (c Calculator) Mult(Num1 int, Num2 int) int {\n\top := MathRequest{Num1, \"Mult\", Num2}\n\tMyCalc.History = append(MyCalc.History, op)\n\treturn Num1 * Num2\n}\n\nfunc (c Calculator) Divide(Num1 int, Num2 int) int {\n\tif Num2 == 0 {\n\t\tprt(\"impossible to divide by zero\")\n\t\treturn 0\n\t} else {\n\t\top := MathRequest{Num1, \"Div\", Num2}\n\t\tMyCalc.History = append(MyCalc.History, op)\n\t\treturn Num1 / Num2\n\t}\n}\n\n/*\n3. create an encodeHistory function this will loop over all the mathRequests in the history slice inside the calculatorA struct and convert all of them into json strings and return a list of strings. You can access the history inside the struct if the function is a receiver using the dot syntax. So something like this:\nfunc (c calculator) encodeHistory() []string {\n    for _, mr := range c.history {\n    }\n}\n*/\n\nfunc check(e error) (ok bool) {\n\tif e != nil {\n\t\tfmt.Printf(\"Error: %s\", e.Error())\n\t\treturn false\n\t}\n\treturn true\n}\n\nfunc (c Calculator) EncodeHistory() (EH []byte) {\n\tEH, err := json.Marshal(MyCalc.History)\n\tif !check(err) {\n\t\treturn nil\n\t}\n\t// prt(\"this is returned from json converter:\", string(j))\n\treturn EH\n}\n\nfunc (c Calculator) SaveToFile(EH []byte, fn string) {\n\tf, err := os.Create(fn)\n\tif !check(err) {\n\t\treturn\n\t}\n\tn2, err := f.Write(EH) // I should check if the file already exists but...\n\tif !check(err) {\n\t\tf.Close()\n\t}\n\tprt(n2, \"bytes written successfully\")\n\terr = f.Close()\n\tif !check(err) {\n\t\treturn\n\t}\n\tf2, err := os.ReadFile(fn)\n\tif !check(err) {\n\t\treturn\n\t}\n\tprt(\"this is \", fn, \" file: \", string(f2))\n}\n\n/*\n4. create a decodeHistory function that will take in a list of json strings as input and convert them into mathRequests and save them as the history inside the calculator slice . At the start of this function clear out whatever was in the slice previously\n\njson.Unmarshal is how you convert a []byte json into a struct passed in as a pointer\n*/\n\ntype MR []struct {\n\tNum1     int\n\tOperator string\n\tNum2     int\n}\n\nfunc (c Calculator) DecodeHistory(fn string) (f []byte) {\n\tf, err := os.ReadFile(fn)\n\tif !check(err) {\n\t\treturn\n\t}\n\t// var data []interface{}\n\t// err = json.Unmarshal(f, &data)\n\terr = json.Unmarshal(f, &MR{})\n\tif !check(err) {\n\t\treturn\n\t}\n\treturn f\n}\n\nfunc (c Calculator) AddToHistory(fn string) {\n\tmr := MR{}\n\tf, err := os.ReadFile(fn)\n\tif !check(err) {\n\t\treturn\n\t}\n\terr = json.Unmarshal(f, &mr)\n\tif !check(err) {\n\t\treturn\n\t}\n\t// for i := 0; i < len(mr)-1; i++ {\n\t// \tMyCalc.History[i].Num1 = mr[i].Num1\n\t// \tMyCalc.History[i].Operator = mr[i].Operator\n\t// \tMyCalc.History[i].Num2 = mr[i].Num2\n\t// }\n\tMyCalc.History = nil\n\tfor i := 0; i < len(mr); i++ {\n\t\top := MathRequest{mr[i].Num1, mr[i].Operator, mr[i].Num2}\n\t\tMyCalc.History = append(MyCalc.History, op)\n\t}\n\tprt(\"this is the last history:\", c.PrintHistory())\n}\n\n// ancillary function\nfunc (c Calculator) PrintHistory() (history []string) {\n\tfor _, v := range MyCalc.History {\n\t\thistory = append(history, fmt.Sprintf(\"%+v\", v))\n\t}\n\treturn history\n}\n"
        }
    ]
}